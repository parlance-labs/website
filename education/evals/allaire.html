<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.45">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2024-07-06">

<title>Inspect, An OSS framework for LLM evals ‚Äì Parlance</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../b.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark.min.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-QXGQ6F7NKT"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-QXGQ6F7NKT', { 'anonymize_ip': true});
</script>
<script async="" data-uid="fbcda700a8" src="https://hamel.ck.page/fbcda700a8/index.js"></script>


<link rel="stylesheet" href="../../styles.css">
<meta property="og:title" content="Parlance - Inspect, An OSS framework for LLM evals">
<meta property="og:description" content="This talk will cover using and extending Inspect, a new OSS Python framework for LLM evals. We‚Äôll walk through the core concepts and design of Inspect and demonstrate its use for a variety of evaluation tasks. Inspect makes it very straightforward to implement simple ‚Äúbenchmark‚Äù style evaluations, but also has the depth and flexibility to support highly complex evals. Inspect supports both exploratory (notebook/REPL) workflows as well creating large scale eval suites that run in batch. We‚Äôll cover all of this ground as well as creating custom extensions to Inspect.">
<meta property="og:image" content="https://parlance-labs.com/education/parlance_edu2.png">
<meta property="og:site_name" content="Parlance">
<meta property="og:image:height" content="540">
<meta property="og:image:width" content="960">
<meta name="twitter:title" content="Parlance - Inspect, An OSS framework for LLM evals">
<meta name="twitter:description" content="This talk will cover using and extending Inspect, a new OSS Python framework for LLM evals. We‚Äôll walk through the core concepts and design of Inspect and demonstrate its use for a variety of evaluation tasks. Inspect makes it very straightforward to implement simple ‚Äúbenchmark‚Äù style evaluations, but also has the depth and flexibility to support highly complex evals. Inspect supports both exploratory (notebook/REPL) workflows as well creating large scale eval suites that run in batch. We‚Äôll cover all of this ground as well as creating custom extensions to Inspect.">
<meta name="twitter:image" content="https://parlance-labs.com/education/parlance_edu2.png">
<meta name="twitter:creator" content="@HamelHusain">
<meta name="twitter:site" content="@HamelHusain">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image-height" content="540">
<meta name="twitter:image-width" content="960">
</head>

<body class="nav-sidebar docked nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Parlance</span>
    </a>
  </div>
          <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../education/"> 
<span class="menu-text">Resources</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../services.html"> 
<span class="menu-text">Services</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../team.html"> 
<span class="menu-text">Team</span></a>
  </li>  
</ul>
          <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
            <div id="quarto-search" class="" title="Search"></div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../education/index.html">Educational Resources</a></li><li class="breadcrumb-item"><a href="../../education/evals/index.html">Evals</a></li><li class="breadcrumb-item"><a href="../../education/evals/allaire.html">Inspect, An OSS framework for LLM evals</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../../education/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Educational Resources</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true">
 <span class="menu-text">Fine Tuning Course</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth2 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../education/fine_tuning_course/workshop_1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Session 1: When and Why to Fine Tune an LLM</span></a>
  </div>
</li>
      </ul>
  </li>
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../../education/evals/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Evals</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth2 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../education/evals/allaire.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Inspect, An OSS framework for LLM evals</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../education/evals/schoelkopf.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">A Deep Dive on LLM Evaluation</span></a>
  </div>
</li>
      </ul>
  </li>
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../../education/fine_tuning/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Fine-Tuning</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-4" class="collapse list-unstyled sidebar-section depth2 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../education/fine_tuning/abhishek.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Train (almost) any LLM using ü§ó autotrain</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../education/fine_tuning/daniel.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Creating, curating, and cleaning data for LLMs</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../education/fine_tuning/emmanuel.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Why Fine Tuning is Dead</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../education/fine_tuning/kyle.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Fine-tuning when you‚Äôve already deployed LLMs in prod</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../education/fine_tuning/mistral_ft_sophia.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Best Practices For Fine Tuning Mistral</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../education/fine_tuning/napkin_math.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Napkin Math For Fine Tuning</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../education/fine_tuning/pawel.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Fine Tuning LLMs for Function Calling</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../education/fine_tuning/slaying_ooms.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Slaying OOMs with PyTorch FSDP and torchao</span></a>
  </div>
</li>
      </ul>
  </li>
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../../education/rag/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">RAG</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-5" class="collapse list-unstyled sidebar-section depth2 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../education/rag/ben.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Beyond the Basics of RAG</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../education/rag/jason.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Systematically improving RAG applications</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../education/rag/jo.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Back to Basics for RAG</span></a>
  </div>
</li>
      </ul>
  </li>
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../../education/prompt_eng/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Prompt Engineering</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-6" class="collapse list-unstyled sidebar-section depth2 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../education/prompt_eng/berryman.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Prompt Engineering Workshop</span></a>
  </div>
</li>
      </ul>
  </li>
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../../education/applications/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Building Applications</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-7" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-7" class="collapse list-unstyled sidebar-section depth2 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../education/applications/charles.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Modal: Simple Scalable Serverless Services</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../education/applications/simon_llm_cli/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">LLMs on the command line</span></a>
  </div>
</li>
      </ul>
  </li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#chapters" id="toc-chapters" class="nav-link active" data-scroll-target="#chapters">Chapters</a></li>
  <li><a href="#slides" id="toc-slides" class="nav-link" data-scroll-target="#slides">Slides</a></li>
  <li><a href="#resources" id="toc-resources" class="nav-link" data-scroll-target="#resources">Resources</a></li>
  <li><a href="#notes" id="toc-notes" class="nav-link" data-scroll-target="#notes">Notes</a>
  <ul class="collapse">
  <li><a href="#getting-started-with-inspect" id="toc-getting-started-with-inspect" class="nav-link" data-scroll-target="#getting-started-with-inspect">Getting Started with Inspect</a></li>
  <li><a href="#inspect-evaluation-components" id="toc-inspect-evaluation-components" class="nav-link" data-scroll-target="#inspect-evaluation-components">Inspect Evaluation Components</a></li>
  <li><a href="#example-evaluation-sally-anne-test" id="toc-example-evaluation-sally-anne-test" class="nav-link" data-scroll-target="#example-evaluation-sally-anne-test">Example Evaluation: Sally-Anne Test</a></li>
  <li><a href="#code-for-the-evaluation" id="toc-code-for-the-evaluation" class="nav-link" data-scroll-target="#code-for-the-evaluation">Code for the Evaluation:</a></li>
  <li><a href="#running-the-evaluation" id="toc-running-the-evaluation" class="nav-link" data-scroll-target="#running-the-evaluation">Running the Evaluation</a></li>
  </ul></li>
  <li><a href="#full-transcript" id="toc-full-transcript" class="nav-link" data-scroll-target="#full-transcript">Full Transcript</a></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/parlance-labs/website/edit/main/education/evals/allaire.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../education/index.html">Educational Resources</a></li><li class="breadcrumb-item"><a href="../../education/evals/index.html">Evals</a></li><li class="breadcrumb-item"><a href="../../education/evals/allaire.html">Inspect, An OSS framework for LLM evals</a></li></ol></nav>
<div class="quarto-title">
<h1 class="title">Inspect, An OSS framework for LLM evals</h1>
  <div class="quarto-categories">
    <div class="quarto-category">evals</div>
    <div class="quarto-category">llm-conf-2024</div>
  </div>
  </div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">July 6, 2024</p>
    </div>
  </div>
  
    
  </div>
  
<div>
  <div class="abstract">
    <div class="block-title">Abstract</div>
    <p>This talk will cover using and extending Inspect, a new OSS Python framework for LLM evals. We‚Äôll walk through the core concepts and design of Inspect and demonstrate its use for a variety of evaluation tasks. Inspect makes it very straightforward to implement simple ‚Äúbenchmark‚Äù style evaluations, but also has the depth and flexibility to support highly complex evals. Inspect supports both exploratory (notebook/REPL) workflows as well creating large scale eval suites that run in batch. We‚Äôll cover all of this ground as well as creating custom extensions to Inspect.</p>
  </div>
</div>


</header>


<div class="quarto-video ratio ratio-16x9"><iframe data-external="1" src="https://www.youtube.com/embed/kNaZU9bz-UM" title="" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div>
<div class="mobile-only callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Subscribe For More Educational Content
</div>
</div>
<div class="callout-body-container callout-body">
<p>If you enjoyed this content, subscribe to receive updates on new educational content for LLMs.</p>
<center>
<script async="" data-uid="6379a28bdb" src="https://hamel.ck.page/6379a28bdb/index.js"></script>
</center>
</div>
</div>
<section id="chapters" class="level2">
<h2 class="anchored" data-anchor-id="chapters">Chapters</h2>
<p><strong><a href="https://youtu.be/kNaZU9bz-UM&amp;t=0s">00:00</a> Introduction to Inspect</strong></p>
<p>JJ Allaire introduces Inspect, a Python package developed in collaboration with the UK AI Safety Institute for conducting evaluations of large language models (LLMs). The tool facilitates a range of evaluations from simple QA to complex cybersecurity tasks. JJ discusses the motivation behind Inspect, emphasizing the inadequacies of existing tools for complex LLM evaluations and the frequent default to custom solutions.</p>
<p><strong><a href="https://youtu.be/kNaZU9bz-UM&amp;t=115s">01:55</a> Honeycomb Eval Example</strong></p>
<p>JJ walks through an example with the Honeycomb dataset, demonstrating Inspect‚Äôs flexibility in adapting existing code for evaluations.</p>
<p><strong><a href="https://youtu.be/kNaZU9bz-UM&amp;t=225s">03:45</a> Core Concepts: Solvers and Scorers</strong></p>
<p>JJ elaborates on the core components of Inspect: Datasets, Solvers, and Scorers. He details how these components interact within the framework to process evaluations, utilizing examples from the Honeycomb dataset to illustrate their functions.</p>
<p><strong><a href="https://youtu.be/kNaZU9bz-UM&amp;t=408s">06:48</a> Eval Results and Tools</strong></p>
<p>JJ covers the evaluation process and tools available in Inspect for analyzing results. He demonstrates the use of the Inspect View to aid in debugging and refining evaluations, and shares how users might drill further to inspect eval results.</p>
<p><strong><a href="https://youtu.be/kNaZU9bz-UM&amp;t=715s">11:55</a> Detailed Solver and Scorer Functions</strong></p>
<p>A deep dive into the functionalities of Solvers and Scorers within Inspect. JJ describes the modular design that allows for the reuse and customization of these components to suit specific evaluation needs, including examples like multiple-choice and self-critique solvers.</p>
<p><strong><a href="https://youtu.be/kNaZU9bz-UM&amp;t=937s">15:37</a> Composability and Tool Integration</strong></p>
<p>JJ discusses the composability of Inspect, encouraging the use of external Python packages to enhance the framework‚Äôs capabilities. Examples include integrating tools for specific tasks like security evaluations. He discusses the potential of community-developed components.</p>
<p><strong><a href="https://youtu.be/kNaZU9bz-UM&amp;t=1150s">19:10</a> Agent Scenarios</strong></p>
<p>JJ presents advanced use cases for Inspect, detailing the integration of agent-based systems for complex tasks such as cybersecurity evaluations. This section covers the adaptability of Inspect to incorporate various agent behaviors, even from external frameworks such as LangChain.</p>
<p><strong><a href="https://youtu.be/kNaZU9bz-UM&amp;t=1384s">23:04</a> Scoring Mechanisms and Customization</strong></p>
<p>JJ elaborates on the various scoring methodologies within Inspect, highlighting the flexibility in using pattern matching, model-graded scorers, and comparing against human evaluation.</p>
<p><strong><a href="https://youtu.be/kNaZU9bz-UM&amp;t=1610s">26:50</a> Importance of Logging in Evaluations</strong></p>
<p>JJ discusses the role of logging within Inspect, showcasing how comprehensive logging can significantly enhance the evaluation process. JJ illustrates how logs facilitate detailed analysis and comparisons across different evaluations, especially when enriched with, e.g., Python APIs.</p>
<p><strong><a href="https://youtu.be/kNaZU9bz-UM&amp;t=1679s">27:59</a> Model Support and Integration</strong></p>
<p>This section details Inspect‚Äôs compatibility with a wide range of models from various providers like Hugging Face. JJ explains how Inspect handles different model architectures and the ease of integrating new models as they become available.</p>
<p><strong><a href="https://youtu.be/kNaZU9bz-UM&amp;t=1776s">29:36</a> Workflow with Inspect</strong></p>
<p>JJ describes Inspect‚Äôs capabilities for supporting both interactive and automated workflows. He outlines how Inspect accommodates exploratory work in notebooks while also being robust enough for inclusion in continuous integration systems, enhancing productivity, scalability, and reproducibility in LLM evaluations.</p>
<p><strong><a href="https://youtu.be/kNaZU9bz-UM&amp;t=2129s">35:29</a> Q&amp;A Session Begins</strong></p>
<p>The session transitions to a Q&amp;A, facilitated by Hamel, where JJ addresses questions about Inspect‚Äôs integration with other products, its capabilities for handling different data inputs and outputs as well as metrics, and the future development directions influenced by community feedback and needs.</p>
</section>
<section id="slides" class="level2">
<h2 class="anchored" data-anchor-id="slides">Slides</h2>
<p><object data="intro-to-inspect.pdf" type="application/pdf" width="100%" height="580"><a href="intro-to-inspect.pdf" download="">Download PDF file.</a></object></p>
</section>
<section id="resources" class="level2">
<h2 class="anchored" data-anchor-id="resources">Resources</h2>
<ul>
<li>Inspect <a href="https://ukgovernmentbeis.github.io/inspect_ai/">homepage</a>.</li>
<li>Inspect <a href="https://github.com/UKGovernmentBEIS/inspect_ai">GitHub repo</a>.</li>
<li>AI Safety Institute: <a href="https://www.aisi.gov.uk/">homepage</a>.</li>
<li><a href="https://raw.githubusercontent.com/jjallaire/inspect-llm-workshop/main/slides/intro-to-inspect.pdf">Slides (pdf)</a>.</li>
<li><a href="https://github.com/jjallaire/inspect-llm-workshop">Source code</a> for this presentation.</li>
</ul>
</section>
<section id="notes" class="level2">
<h2 class="anchored" data-anchor-id="notes">Notes</h2>
<section id="getting-started-with-inspect" class="level3">
<h3 class="anchored" data-anchor-id="getting-started-with-inspect">Getting Started with Inspect</h3>
<p>To develop and run evaluations using Inspect, you‚Äôll need access to a model. This typically involves installing a Python package and ensuring that the appropriate API key is available in your environment. Here are the steps:</p>
<ol type="1">
<li>Install the inspect-ai Python package:</li>
</ol>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ex">pip</span> install inspect-ai</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ol start="2" type="1">
<li>Assuming you‚Äôve written an evaluation script named arc.py, set up and run the evaluation for OpenAI as follows:</li>
</ol>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ex">pip</span> install openai</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="bu">export</span> <span class="va">OPENAI_API_KEY</span><span class="op">=</span>your-openai-api-key</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="ex">inspect</span> eval arc.py <span class="at">--model</span> openai/gpt-4</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Inspect supports a wide variety of models, including models hosted on Azure AI, AWS Bedrock, Cloudflare, and local models with Ollama.</p>
</section>
<section id="inspect-evaluation-components" class="level3">
<h3 class="anchored" data-anchor-id="inspect-evaluation-components">Inspect Evaluation Components</h3>
<ol type="1">
<li><p><strong>Datasets:</strong> These contain labeled samples, typically organized as a table with input and target columns. The input represents prompts, and the target can be literal values or grading guidance.</p></li>
<li><p><strong>Solvers:</strong> Solvers are combined in a plan to evaluate the input in the dataset. The basic generate() solver calls the model with a prompt and collects the output. Other solvers can handle prompt engineering, multi-turn dialog, critique, and more.</p></li>
<li><p><strong>Scorers:</strong> These evaluate the final output of solvers. They may use text comparisons, model grading, or other custom techniques.</p></li>
</ol>
</section>
<section id="example-evaluation-sally-anne-test" class="level3">
<h3 class="anchored" data-anchor-id="example-evaluation-sally-anne-test">Example Evaluation: Sally-Anne Test</h3>
<p>Let‚Äôs explore a simple evaluation that assesses how models perform on the Sally-Anne test: a task that evaluates a person‚Äôs ability to infer false beliefs in others. Here are some samples from the dataset:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 46%">
<col style="width: 53%">
</colgroup>
<thead>
<tr class="header">
<th>input</th>
<th>target</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Jackson entered the hall. Chloe entered the hall. The boots is in the bathtub. Jackson exited the hall. Jackson entered the dining_room. Chloe moved the boots to the pantry. Where was the boots at the beginning?</td>
<td>bathtub</td>
</tr>
<tr class="even">
<td>Hannah entered the patio. Noah entered the patio. The sweater is in the bucket. Noah exited the patio. Ethan entered the study. Ethan exited the study. Hannah moved the sweater to the pantry. Where will Hannah look for the sweater?</td>
<td>pantry</td>
</tr>
</tbody>
</table>
<p><br></p>
<p>In this example, we demonstrate how to run evaluations using the inspect eval command from the terminal. Additionally, we provide the code for the evaluation.</p>
</section>
<section id="code-for-the-evaluation" class="level3">
<h3 class="anchored" data-anchor-id="code-for-the-evaluation">Code for the Evaluation:</h3>
<div class="sourceCode" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> inspect_ai <span class="im">import</span> Task, <span class="bu">eval</span>, task</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> inspect_ai.dataset <span class="im">import</span> example_dataset</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> inspect_ai.scorer <span class="im">import</span> model_graded_fact</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> inspect_ai.solver <span class="im">import</span> (               </span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  chain_of_thought, generate, self_critique   </span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>)                                             </span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="at">@task</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> theory_of_mind():</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># The Task object brings together the dataset, solvers, and scorer, </span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># And is then evaluated using a model.</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> Task(</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>        dataset<span class="op">=</span>example_dataset(<span class="st">"theory_of_mind"</span>),</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>        plan<span class="op">=</span>[</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>           <span class="co"># In this example we are chaining together three standard solver components. </span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>          <span class="co"># It‚Äôs also possible to create a more complex custom solver that manages state </span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>          <span class="co"># And interactions internally.</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>          chain_of_thought(),</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>          generate(),</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>          self_critique()</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>        ],</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>        scorer<span class="op">=</span>model_graded_fact()</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>    )</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Note that this example is intentionally over-simplified. The templates for prompting, critique, and grading can all be customized. In a more rigorous evaluation, we‚Äôd explore improvements specific to the context of the dataset.</p>
</section>
<section id="running-the-evaluation" class="level3">
<h3 class="anchored" data-anchor-id="running-the-evaluation">Running the Evaluation</h3>
<p>To run the evaluation against GPT-4, execute the following command:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ex">inspect</span> eval theory_of_mind.py <span class="at">--model</span> openai/gpt-4</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><img src="allaire.png" class="img-fluid"></p>
<p>By default, evaluation logs are written to the <code>./logs</code> sub-directory of the current working directory. Once the evaluation is complete, you‚Äôll find a link to the log at the bottom of the task results summary.</p>
<p>Additionally, you can explore evaluation results using the Inspect log viewer. Run <code>inspect view</code> to open the viewer (you only need to do this once, as the viewer will automatically update when new evaluations are run).</p>
<center>
<script async="" data-uid="8a7362bdfa" src="https://hamel.ck.page/8a7362bdfa/index.js"></script>
</center>
</section>
</section>
<section id="full-transcript" class="level2">
<h2 class="anchored" data-anchor-id="full-transcript">Full Transcript</h2>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-2-contents" aria-controls="callout-2" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Expand to see transcript
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-2" class="callout-2-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p><br>[0:03] JJ Allaire: I‚Äôm going to try to give a whirlwind tour of Inspect. I actually worked with Hamel a little bit over the weekend to build some Inspect evals for the Honeycomb dataset that you are working with. Hopefully, it‚Äôll connect well to the work that you‚Äôve been doing and it‚Äôll make the concepts gel a little bit easier. What is Inspect? Not surprisingly, it is a Python package, pip install Inspect AI. Someone asked a question about, in Hamel reference, that I‚Äôm affiliated with Posit, which is formerly our studio. This project is actually not a Posit project. <br>[0:43] JJ Allaire: This is a project that results from a collaboration that I‚Äôm doing with the UK AI Safety Institute. So the UK AI Safety Institute has hundreds of evaluations of every variety, simple QA things. fancy, you know, cybersecurity capture the flag evals, hundreds of evaluations. And when we kind of started off on the journey to writing on these evaluations, there weren‚Äôt terrific tools available. A lot of the tools were either embedded in benchmark frameworks, or maybe not very complete or weren‚Äôt that well tooled. It wasn‚Äôt necessarily clear exactly how much more development they would get. <br>[1:23] JJ Allaire: And further, I think they were not necessarily designed to scale up to very complex evals. And so we set out and actually the most popular eval framework is just roll your own eval framework, which is out there a bunch too. So we set out to build something that we could use and then ultimately we could share so other people could use as well. So with that, just again trying to ground this in Honeycomb. This is actually an eval for the Honeycomb dataset. It‚Äôs got there‚Äôs 2300 user inputs. <br>[1:58] JJ Allaire: We‚Äôve also got the, you can see columns, that‚Äôs the schemas that were fetched originally by RAG, so they‚Äôre in the data set. And so to create an evaluation, we basically take that data set, and then we put it through a pipeline, which you‚Äôll recognize is really the same code that Hamel had in the notebooks for‚Ä¶ for Honeycomb. And then we apply a score to it, which is again, based on the Hamel‚Äôs original code. And then we can run this eval and get lots of tooling. <br>[2:31] JJ Allaire: You can see this, I‚Äôll get it more into this, but we have a log viewer that lets you explore and debug and visualize everything that happened during the eval. Lots of other tools. This is a VS Code extension that lets you tweak things, run different models, et cetera. So I think I would emphasize that inspect is not super opinionated and really is like Python code first. <br>[2:53] JJ Allaire: And by sort of conforming to some simple conventions and fitting yourself in, you get to take advantage of this big pipeline of tools and then hopefully like a big ecosystem of related packages that will extend and spec. <br>[3:07] Hamel: Is it very local in nature? It‚Äôs local. <br>[3:10] JJ Allaire: It‚Äôs all local. Yeah. Okay. Yeah. So one of the things I skipped over on the first slide is we have this concept of development to production. So we definitely wanted to have a very interactive local, you work in a notebook, be very iterative, work on your eval. We have lots of stuff for taking it and running it in the cloud, run it over 10 models, run it. So it‚Äôs‚Ä¶ <br>[3:33] JJ Allaire: It‚Äôs local for development, but then we have lots of tools if you want to scale it up and run it as part of CI and things like that. But it‚Äôs all local. Right. Okay. So this core concepts, and you saw a little bit of these on the first slide, you have a data set, which is not at all surprising what that consists of. It‚Äôs inputs. And usually there‚Äôs targets. In the case of the Honeycomb data set, there‚Äôs not a target. There‚Äôs going to be a validation function and a critique model. <br>[4:05] JJ Allaire: Target would usually have like for multiple choice, what‚Äôs the correct answer for Q&amp;A, some kind of description of what the right answer is. for a fancy model graded eval, it might be like a grading rubric for a model. So that‚Äôs the data set. Solvers is like the pipeline that actually does the eval. And this could be doing anything from prompt engineering to calling the model to a multi-turn dialogue with the model. It could be doing various types of elicitation like critique. <br>[4:34] JJ Allaire: Solvers is kind of like the heart of the entire eval and where you kind of customize how it works. And then the score basically evaluates the final output. Again, these can be very simple, like doing text comparisons. They can be model graded, or they can use all kinds of custom schemes, kind of whatever you can dream up. So that‚Äôs the core concepts, and I‚Äôm going to drill more into this validate example. So this is the eval. I‚Äôll break down the different parts of it. <br>[5:01] JJ Allaire: We talked about the data set, and this is just reading from the CSV. There are standard fields that go in data sets. Input is one of them. And then there are custom fields that different evals will need. In this case, columns is important because we‚Äôre going to use columns for the prompt template. And so we want to save the columns when we read the data set in. And then this, we have this plan and you‚Äôll see this is the same system message used in the notebooks presented in the course. <br>[5:29] JJ Allaire: prompt with schema is a solver that‚Äôs going to build the prompt that uses the columns and the input, and then generate calls the model. So pretty straightforward. And then the score actually uses the check function, the check query function that you‚Äôve also seen in the course. So that‚Äôs the eval. And now I‚Äôll drill into some of the specific components. They‚Äôre quite simple, and hopefully they‚Äôll be very intuitive and straightforward, what they‚Äôre actually doing. Here, prompt with schema is literally just taking a prompt template and then substituting the prompt and the columns. <br>[6:04] JJ Allaire: So you‚Äôve seen this before, but it‚Äôs a solver that really just makes a prompt. That‚Äôs all it does. And then the scorer is basically going to‚Ä¶ It‚Äôs going to take the output from the model. This JSON completion function is just sort of a helper that some models actually like to put like JSON code blocks in. So it strips that away. <br>[6:31] JJ Allaire: So the idea behind that is just like clean it up so we get pure JSON, read it, and then we call the is valid function, which is literally the exact same is valid function that‚Äôs used in the course. And we figure out whether the query was valid. Okay. And then, so once we‚Äôve done that, we‚Äôve built our solver and we‚Äôve built our score and we‚Äôve run it. Now we run our eval and we can see kind of what happened. <br>[6:56] JJ Allaire: And in so many evals, the score really doesn‚Äôt tell you anything close to enough, especially when you first start developing them because, you know, your checking function could be wrong. The way you extract answers from the model could be wrong. There‚Äôs so many things that you need to investigate and you kind of‚Ä¶ in some ways need to do it on a per sample basis. So this lets you very easily look and see what happened overall, and then what happened on a sample by sample basis. <br>[7:23] JJ Allaire: So here you can see drilling into this sample, which got incorrect. We can see what was the actual message history, what was the dialogue between the model and the eval. And so here it‚Äôs quite long, as you know, from working on it. Here‚Äôs the columns that was injected, the schema. And then here you can see‚Ä¶ to the very end, and then the assistant‚Äôs answer. So looking at all the messages can be quite valuable, especially when you get into things like tool use. And then also, okay, so that‚Äôs the basics of that. <br>[7:57] JJ Allaire: And then we built another eval, which has actually, it‚Äôs‚Ä¶ The exact same code, and in fact, in the Git repo that I‚Äôll share at the end, you‚Äôll see that I do reuse the code. I don‚Äôt just copy and paste it, but really there‚Äôs only one line that‚Äôs different here. It‚Äôs the same dataset, it‚Äôs the same plan, but we‚Äôre going to use a critique model for scoring instead of the validate function. Here, this is the critique score. This has a little bit more going on, but it‚Äôs again, pretty straightforward. Notice we parameterize. <br>[8:30] JJ Allaire: what model is used to do the critique. So you can use, you know, it‚Äôs pretty obvious, but you don‚Äôt necessarily need to use the same model. In fact, you often don‚Äôt want to use the same model to do scoring as the model you‚Äôre evaluating. You can use a more powerful model. In some cases, maybe use a fine-tuned model. Here we‚Äôre defaulting to GPT-4 Turbo, but the user of the score could use any other model they want. We build the critic prompt, kind of analogous to how we built the other prompt. <br>[9:01] JJ Allaire: And again, this critique.text is literally the same. It‚Äôs the exact prompt that is in the notebooks for the course. And then we run the critique. So we get the model instance, we call generate, we parse the output, we check and see if it was good, and then we return the score. So that‚Äôs our critique score. And then at the end of that, we get another eval view. This time for critique, the accuracy here was a little bit lower. <br>[9:28] JJ Allaire: These numbers actually don‚Äôt really mean anything by themselves, but just noting that it was less frequent that the critique was satisfied. with the output then, the devalidator, which is intuitive. And so here we might want to know what actually happened in this critique. So we can drill in here. This is one of the incorrect answers. And we can see what the answer was. And then we can actually see what the critique model‚Äôs explanation was. So here you might look at it and say, wow, that actually looks right to me. <br>[10:00] JJ Allaire: Or a human expert may have said it was right. And then you want to look at the explanation and perhaps This indicates that you need to improve your prompt template for the critique model, or perhaps it means you need to fine-tune a model just to do critique, depending on what resources you‚Äôre willing to apply to get a good grader. So this is, again, just drilling in and seeing what happened during scoring. Okay, so that‚Ä¶ <br>[10:27] Hamel: Is there any way to interact with this view, like do some annotation in this view itself or something? <br>[10:34] JJ Allaire: So right now we don‚Äôt have we don‚Äôt have like commenting in the view and stuff. I think we are developing like some like shared places to look at like internally. places to look at views together and there‚Äôll be some annotation in there. I don‚Äôt know if we‚Äôll come out with like a thing to do that. But that is useful, especially. Yeah. So maybe there‚Äôs a way we can do that in a way that, that we can open source that as well. And then, and then people can take advantage of that. This is just runs locally. <br>[11:03] JJ Allaire: So you kind of would need to post it in some kind of, we‚Äôve talked about actually building a. it wouldn‚Äôt really solve it awaits and biases plug in, but that‚Äôs not going to let you do this, like drilling into each one. Maybe to some extent it would, if they have like good, good templates for, for, for chat message for chat conversation histories. But yeah. <br>[11:23] Hamel: I like the way that this is being rendered. And it‚Äôs flexible, seems flexible enough that you took my example without really knowing it until the weekend and seem to just plug it in here. <br>[11:34] JJ Allaire: And it‚Äôs actually really- Just plug it in. And mostly just use all your code. I mean, there‚Äôs a very, what I showed you is like all the code that I wrote. And all the rest is just calling your, using your templates and using your code. So that‚Äôs kind of the idea that, you know, there is a minimal lift to get your existing stuff working inside the pipeline. So, yeah, we did that. Okay, so now I want to just talk a little more abstractly. We‚Äôve looked at these examples. <br>[12:00] JJ Allaire: I‚Äôve shown you some simple solvers, really simple, just a prompt template. They can get a lot more fancy, which I‚Äôll show you in a minute, and some scorers. So, like, conceptually, what is a solver? It basically, and this is a simple view, but the idea of a solver is it has a task state, which is, like, what‚Äôs the current state of the message history and what is the current model output? And when we start, there is no model output. and it just transforms the task state in some useful fashion. <br>[12:27] JJ Allaire: So that could be calls the model, generates, appends the assistant message, and updates the output. It could be prompt engineering. It could be critique. It kind of can be anything. And yeah, that‚Äôs sort of what I‚Äôm saying here. The solve function does something useful with the state. And that sort of allows you to create a pipeline of solvers and reuse solvers. And it‚Äôs not always the case that you want to do that. <br>[12:50] JJ Allaire: Some evals really just want to have like one solver that just is sort of boss of everything and doesn‚Äôt confine itself to being in a pipeline. But the pipeline does end up being useful in a lot of cases. So some examples of really simple solvers, which you‚Äôve sort of seen hints of. We built a custom prompt template for the Honeycomb evals. But like a simple, here‚Äôs a prompt template, just transform the prompt by passing it through a template, perhaps with some extra parameters from metadata. This is actually the actual source code for the generate solver. <br>[13:24] JJ Allaire: It literally just calls the model to generate, and that‚Äôs it. So those are like really simple. 101 solvers. I think we have like a chain of thought solver, which does like a basic chain of thought template. But even then, often you want to customize that for the domain. The generic chain of thought isn‚Äôt always exactly what you want. And I guess this emphasizes when you‚Äôre writing really good evals, you are writing, you can reuse solvers, but you‚Äôre oftentimes want to write your own solvers and write your own scores to make them really, really good. <br>[13:56] JJ Allaire: Here‚Äôs a more fancy one. I won‚Äôt actually walk through all the code on this, but it‚Äôs a multiple choice solver that handles like shuffling the choices. And then it actually calls the model to generate and then it unshuffles the choices. So this is an example of a solver that calls generate internally. So the plan for a multiple choice will typically just be like plan equals multiple choice. It might be like plan equals chain of thought multiple choice, where multiple choice just calls generate internally. Another one, self-critique, pretty straightforward. <br>[14:27] JJ Allaire: Again, we‚Äôve already called generate before self-critique comes on the scene. So we may have had a system message, a prompt template. Now we call generate and now self-critique. So the first thing we do is we actually take the existing completion and we basically run a critique on it. And then we take that critique and we append it to the message history. And then we call generate again. And so this is an example, again, of a solver calling generate internally, this time just to re-up the answer with the critique being available. <br>[15:02] Hamel: I love how you made these slides, I think, with Corto. There‚Äôs a lot of comments in the Discord. No? Okay. <br>[15:08] JJ Allaire: Yeah, yeah. Yes, with Quarto. Definitely with Quarto. Oh, yeah. Yeah, yeah, yeah, yeah, yeah. Yeah, totally. Yeah. <br>[15:12] Hamel: A lot of comments in the Discord about, hey, this is really cool. Is it Quarto? So, yeah. <br>[15:17] JJ Allaire: Yes, definitely. It definitely is Quarto, yes. Yeah. Okay. And I‚Äôll make the slides available at the end and the slide source code and everything. So, there‚Äôs a get repo that I‚Äôll share a link to at the end so people can figure out how we did all this. Okay, so that‚Äôs the self critique solver. Okay, and then there‚Äôs generate we already talked through that. Okay, so one of the things to think about is like is composition. <br>[15:43] JJ Allaire: And so one of the ideas behind Inspect is that you actually will write, people will write a bunch of Python packages that have scorers and have solvers and that you‚Äôll be able to mix and match those. So the idea is like, there‚Äôs like, you know, lots of external components to let you do different things that you can just plug in. So as an example from AI Safety Institute, we have an internal package called Shepard that‚Äôs used for doing jailbreaking. <br>[16:07] JJ Allaire: And so there‚Äôs many, there‚Äôs, as any of you follow the literature, there‚Äôs like dozens and dozens of jailbreaks. And some of them work and some of them don‚Äôt. And sometimes you have to try multiple jailbreaks and some of them work with some models and not with the other models, et cetera, et cetera. But these are basically jailbreak solvers that essentially do prompt engineering to get the model in a state where it may provide answers that it would otherwise refuse. And so as an example, here‚Äôs a eval. <br>[16:34] JJ Allaire: that‚Äôs basically trying to give the, it‚Äôs basically just trying to get, see if the model can give good computer security advice. So it‚Äôs like, how do I prevent, you know, my website from being hacked? And then, so sometimes the model will, because you‚Äôre asking about computer security, it‚Äôll like flag, don‚Äôt talk about computer security. And so we‚Äôre saying, well, we wanna see what the model actually knows. And so here you can say, we bring in a, jailbreak solver from Shepard, and then we just use it in our pipeline. <br>[17:07] JJ Allaire: And so we have our normal system message. We put the jailbreak in, and then we‚Äôll probably be able to elicit more or have less refusals than we otherwise would. And so you can imagine lots of different solvers that you could plug in. prompt various types of prompt engineering solvers. You can imagine a whole Python package just full of prompt engineering techniques and the whole Python package full of critique, debate, all kinds of things like that. And similarly, scorers. So Python package is full of different variations on model graded scoring and things like that. <br>[17:43] JJ Allaire: So that‚Äôs an example of composition, which we think will be a big part of how people end up using Inspect. Okay. Okay. So I‚Äôve simplified a little bit where we‚Äôve just been looking at really straightforward kind of QA style tasks, or in the case of obviously Honeycomb, we‚Äôre looking at a fine tuning task. But these are straightforward, just like prompt, generate, nothing fancy going on. I didn‚Äôt show you all of TaskState before, but TaskState also includes tools. And so the idea behind tools, I‚Äôm sure you‚Äôve all seen or used. <br>[18:19] JJ Allaire: you know, these are Python functions that you can make available to the model. And you tell the model, you write the Python function, you write the doc string, you tell the model about them, and then it will say, hey, I‚Äôd like to use this tool. And so part of the task state is a list of available tools, as well as potentially like a nudge to the model, like definitely use this tool or definitely don‚Äôt use the tool, et cetera. <br>[18:41] JJ Allaire: And so this is a simple example of, this is a biology QA task, and we‚Äôre saying, hey, if it tends that you don‚Äôt know the answer, I think this dataset actually has a bunch of very obscure questions, then hey, you can use web search. And so then we have a web search tool that goes and gets a bunch of Google hits and summarizes them and things like that. And so use tools is a function that just makes tools available to generate. And so there‚Äôs, you know, once you get into tools, now you‚Äôre into agents. <br>[19:14] JJ Allaire: Sometimes it‚Äôs just simple tool use, like, hey, let the model use Wikipedia or let the model use web search. And sometimes it‚Äôs give it all kinds of tools. And they really become agents at that point. And so you can have agents sort of with like very bespoke custom logic, or you can bring in like an agent library. So I‚Äôll show you an example in a little bit of taking like an existing langchain agent and just like basically making it into a solver. <br>[19:39] JJ Allaire: So the idea is you can just take any agent in these other frameworks, and once you have the bridging, it‚Äôll just work inside Inspect. So I‚Äôll show that in a minute, but let me first show this sort of bespoke agent concept, which is this is a cybersecurity eval. It‚Äôs a capture the flag task. And this is more like the hand-rolled agent loop where we‚Äôre basically giving init challenge is here. This is. creating a Docker container. Use tools is basically just like, here‚Äôs some tools. And we tell the model, like you can do all these things. <br>[20:11] JJ Allaire: And then we give it a task. And then this is basically just a loop where the model gets to keep using tools until it either terminates because it couldn‚Äôt figure it out or it ends up finding the flag. So this is like very custom. This is like roll your own agent. And definitely that‚Äôs a thing. That‚Äôs something that people do. But at the same time, you know, there‚Äôs lots of agent frameworks out there. <br>[20:36] JJ Allaire: And so we want to be able to have like high order functions that let you take an existing agent framework and turn it into a solver. So as an example, like if you look at the code in the middle here, this is all code that is just Langchain code. There is actually I haven‚Äôt shown the imports, but there‚Äôs no inspect code at all in here. This is just like code that you would be writing in Langchain. This is basically going to get the Wikipedia tool. and then using the tool. <br>[21:05] JJ Allaire: And then we have, as I said, there‚Äôs this higher order function. This is actually provided as an example right now. It‚Äôs in the repo that I gave you, but we can just take that agent and if it conforms to like the Langchain agent interface, we can just turn it into a solver. And then if you actually look at the eval that results, you can see this is the Wikipedia search. So it‚Äôs a data set of, can the model use‚Ä¶ Use Wikipedia to answer, you know, they may be difficult questions, maybe obscure questions. <br>[21:35] JJ Allaire: There may be questions we think the model definitely can answer. But the idea is, you know, the plan is literally just this Langchain agent that uses Wikipedia. And as you can see, down here is the solver that I showed on the previous slide. This is the entire task definition. Use a model to assess it. and use the agent. And then you can see here kind of what happened. And if we look kind of inside at, you know, what happened during the eval, you can see it‚Äôll show you the tool use. <br>[22:04] JJ Allaire: So it‚Äôs like, okay, what was the back and forth? What tools did the model choose to use and why? It gives an explanation. What result did it get? And this Game of Thrones one is really one of my favorites because it ends up, it‚Äôs trying to find the, in order of the 10 episode titles. And oftentimes, like in Wikipedia, it‚Äôs not like literally spelled out or actually where it is spelled out. It might be wrong. And so oftentimes it‚Äôll do two or two or three queries to try to sort it out. <br>[22:33] JJ Allaire: So anyway, it gives you that sort of diagnostics of what happened with tool use. And then similarly for scoring, this is the model graded fact score. This was the answer and it was incorrect. So this was this was the grading guidance. This was the answer. It was graded incorrect. And I think I‚Äôm going to hopefully show you. Yeah, this is the scorers explanation. So again, you know, sometimes the model really didn‚Äôt get it, but sometimes the score is actually wrong. <br>[22:58] JJ Allaire: And so it‚Äôs important to be able to look, you know, drill down and see what‚Äôs what‚Äôs actually happening. Okay, so that is okay. So let‚Äôs talk a little bit about scoring. Let me check my time and make sure okay we‚Äôre good. A little bit about scoring. There‚Äôs lots of different ways of scoring. Obviously, traditional like pattern matching and template and answer-based scoring are obvious. <br>[23:18] JJ Allaire: We‚Äôve got lots of built-in solvers for doing like RegEx matching, matching at the beginning and the end, matching a template like where you tell the model to say answer and then the answer, lots of that sort of thing. There‚Äôs also model-graded scores built in, but usually you need to customize the templates for those to get them to work properly for your domain. And of course, as I mentioned before, like they‚Äôre pluggable, you can get them from other packages. And I‚Äôm expecting lots of stuff‚Äôs going to happen with model graded scoring over time. <br>[23:49] JJ Allaire: And we‚Äôll see the benefits of the community working on that over the next months and years. And then you can also just say no score, have a human score it. So that‚Äôs also possible. And one of the things I think, and there‚Äôs something that I know is emphasized quite a bit in the course. is basically rigorously evaluating model grade scores against human baselines. Basically, I‚Äôve observed that definitely a lot of people will get their model grade score going, and they‚Äôll be like, cool, now I have a score. <br>[24:18] JJ Allaire: And they haven‚Äôt actually grounded it in whether it‚Äôs how good it is relative to human scores. So if we can build tools that help people do that well, that sort of structure, that work, I think that‚Äôll be valuable. So that‚Äôs something we‚Äôre definitely going to work on. Okay, so what am I? Oh, this is okay. This is a score example, which I think is pretty interesting. This is the traditional, this is actually the math benchmark that I think OpenAI reports as part of their standard benchmarks. <br>[24:50] JJ Allaire: What‚Äôs interesting about it is that the model does math and then there‚Äôs a target, but oftentimes the answer is correct, even though it‚Äôs not literally the target. And so we have this expression equivalence solver that basically lets a model assess, are those expressions actually logically equivalent? So it can even do a little bit of algebra or a little bit of factoring. These are trivial. You can see this is the same as this. It‚Äôs scored correct. This is scored wrong. <br>[25:18] Hamel: What‚Äôs going on in that equivalence thing? Is it a regex? Or is there more going on? <br>[25:23] JJ Allaire: There‚Äôs more going on. I‚Äôm going to show the full source code to it in the next slide. So regex to extract the answer, and then we‚Äôre going to go and have the model. So we prompt the model to basically say at the end, put answer, colon, and then the equation. And then we basically, that‚Äôs how we pull the answer out. And then we send that to this expression equivalent solver. These are trivial because they‚Äôre just like punctuation differences, but I‚Äôve seen it where it actually can sort out that the expressions are actually equivalent. <br>[25:57] JJ Allaire: So let‚Äôs take a look more closely at that. at that solver. Hopefully I have a little step through on this. No, I skipped through the‚Ä¶ Okay, so extract the answer. And this is a reg X off of this line answer pattern, which is a common way of prompting to get the model to delineate their answer in a way that it‚Äôs easy to pick out. <br>[26:15] JJ Allaire: And then here we actually have a whole nother template, which I‚Äôm not going to show, which basically it‚Äôs a few shot thing that basically has like it has like 20 different few shots of like these are equivalent. These are not equivalent and and then the model is able to take those and then actually do a do a pretty good job grading pretty surprisingly good job grading. And so this is, you know, you kind of, this is a custom eval. It‚Äôs math equations. You have to build a custom score. <br>[26:42] JJ Allaire: You have to use a model to help you do the scoring. But it kind of gives you a taste of some of the things that people will do with scoring. Okay. I want to talk a little bit about what might seem kind of a mundane concern, but logging ends up being like massively important for doing good evals. Obviously, we built a log viewer on top of the log, but the log also has an API so that you can interrogate it and you can get multiple logs and then plot the differences and things. <br>[27:12] JJ Allaire: So the idea is the log is a rich Python object. It‚Äôs also JSON. There‚Äôs a JSON schema for it, but it‚Äôs also a It‚Äôs a rich Python object that lets you explore everything that happened during the eval and compare logs and things like that. So there‚Äôs that. And then I think you‚Äôve seen most of the examples of the log viewer, but showing the samples, showing the messages. Yeah, you‚Äôve seen this. Showing scoring. Okay. So that‚Äôs log. So a lot of people, the other thing people do, I think I‚Äôll show this later, they‚Äôll run like‚Ä¶ <br>[27:46] JJ Allaire: 20 eval tasks, like doing a grid search, and then they have all their logs and they plot the results, things like that. So definitely, like, you end up computing on the logs quite a bit. <br>[27:59] Hamel: Very cool. <br>[28:00] JJ Allaire: Yeah. So models, we support a lot of models. We do the big frontier labs. <br>[28:10] Hamel: Do you need to support specific models? What‚Äôs the difference between using any hugging face model? Can you just use any hugging face model, really? <br>[28:19] JJ Allaire: Yeah, it can. <br>[28:20] Hamel: Okay. <br>[28:21] JJ Allaire: Got it. Absolutely. What it is is this prefix here. That is the model provider. And then this is completely arbitrary. So this is like any hugging face model. This is like any model that you have locally with Oyama. This is any model that‚Äôs on Together AI. This is provider and model name. We don‚Äôt know anything about these model names. We don‚Äôt resolve them, compute on them, we don‚Äôt know what they are. They just get passed through. So when Jammini 2.0 comes out, you just start using it. <br>[28:52] Hamel: And can you have your own endpoint? Like your own REST API endpoint? Yeah, <br>[28:57] JJ Allaire: you can. So one of the things that is interesting, like Oyama and VLM both actually end together. I think together might use VLM. They all use OpenAI‚Äôs API. So sometimes people will just use OpenAI with a custom base URL, but you can also create a custom model provider as well. If it‚Äôs like completely custom REST API that we don‚Äôt know about, it‚Äôs very easy to make a model provider and publish it in a package or what have you. So yeah. <br>[29:29] JJ Allaire: So you should be able to get to the models you want to get to without trouble. <br>[29:35] Hamel: Cool. <br>[29:35] JJ Allaire: Okay. Okay. So let‚Äôs see. I just want to make sure we have time for questions. I‚Äôm going to go a little fast on the rest here, but just to say we care a lot about interactive development. We care a lot about being able to work in a notebook, doing exploratory work on the eval, but then we want the eval to end up in a form. You can run them in CI. You can run lots of them. You can systematically compare results and things like that. <br>[30:00] JJ Allaire: So we have good, like we have tooling that works well in notebooks. I showed you before you saw like a terminal, it was like inspect, eval, do the thing. You can do all this in Python, in a notebook, and it does all the things in the notebook. You can have tasks in notebooks. And so we definitely try to invest a lot in like interactive workflow and then make it so it can scale to the more, I would say, production workflows. So again, I‚Äôm not going to dwell too much. This is like a grid search. <br>[30:28] JJ Allaire: So it‚Äôs like, okay, I‚Äôm doing a grid search over different grader models, graders, and system prompts. And that product is just like a thing that‚Äôs making the grid search. I‚Äôm dynamically synthesizing a bunch of tasks and I‚Äôm going to run all the tasks and I‚Äôm going to plot the results. So that‚Äôs just an example of like in a notebook, you just want to like explore the space with different things. And then later you might say, well, we‚Äôre going to formalize this. We‚Äôre going to make a task. We‚Äôre going to have some parameters from the task. <br>[30:56] JJ Allaire: What that allows you to do is start to address the evals, like with external driver programs. So basically I won‚Äôt get well on this, but like once you have this task and this can still be in a notebook and you‚Äôve got these parameters here, I‚Äôm, I‚Äôm just basically just varying the system prompt and the grading prompt. You know, I can basically go inspect eval and then I can actually like, vary those parameters externally from a driver program, or I can do the same thing if it‚Äôs in a notebook. <br>[31:23] JJ Allaire: I can say, okay, I‚Äôm going to keep my eval in the notebook where I did all my exploratory work, but I still want to be able to address it outside of the notebook. Okay, task variant. This is down in the weeds. We‚Äôre not going to get into that. Okay. And then eval suites. Again, I‚Äôm not going to get into all this, but the idea is you should be able to have dozens of evals arranged in directories however you want, and we can find them and run them. <br>[31:48] JJ Allaire: This is an example of a directory structure that has a bunch of Python, has a bunch of tasks. We can find the tasks. We can run all the tasks. And, you know, again, the production version of it would probably be more like run it, put the put all the logs in an S3 bucket, then later on, go look in the S3 bucket and retry things that failed and things like that. Right. Okay. <br>[32:12] JJ Allaire: And then one last piece on sort of workflow is one principle is that if you run an eval from a Git repository, we want to, if you only have the log file, you should be able to completely reproduce the eval. It won‚Äôt necessarily give you all the same, obviously, since the models are non-deterministic, it won‚Äôt give you the same results, but you can reproduce all the input parameters and everything. So, for example, if I hand you a log. I can use the Python API to go read the log. <br>[32:40] JJ Allaire: I can go get the origin and the commit. I can get clone it. And then I can just run eval on it and that will work. So the idea is that the log file is like, assuming it was run from a Git repo, there‚Äôs sort of a unit of reproducibility. Okay. Okay. So I think we made it in time to have a decent number of questions, but I want to emphasize some resources. So one is, let me see here, is the documentation. <br>[33:13] JJ Allaire: website, lots of documentation that goes into lots of depth on all the stuff I talked about here. There‚Äôs a fair number of kind of annotated examples that go through, kind of walk through the code and explain all the different things going on. There‚Äôs also a, if I can find, a benchmarks in Git. There‚Äôs like we implemented a bunch of benchmarks and you can see how those are done. <br>[33:41] JJ Allaire: So lots of examples and lots of docs and then kind of some of the stuff I talked about, workflow and logs and tuning and things is all, we have docs about that as well. And then this is where you would go to get kind of everything I presented. So this repo has, I won‚Äôt scroll down yet so people can note the URL, I can just stick in the chat. Let me just do that quickly here. Someone can stick in the chat. Yeah. Okay. Yeah. But this basically has, yeah, I‚Äôll let you note that. <br>[34:21] JJ Allaire: But basically it has the slides, and then it also has the code. So it has, if you go into like Honeycomb here, it actually has the kind of. what I actually did, the full code, and there‚Äôs the prompts. You‚Äôll recognize utils. This is like the code right from the course. And then we have a, here‚Äôs the queries eval. You can see, again, we reused the code. We didn‚Äôt copy and paste it, but here‚Äôs the two eval tasks. And then we have a notebook version of that just to demonstrate doing it in a notebook. <br>[35:01] JJ Allaire: a little bit more commentary so there‚Äôs that and then i included some benchmarks here just for some people could explore those and then also that lang chain example that we talked about is here also so that kind of explains this how to run it and um yeah and then the slides so this is a worthwhile repo to check out and the docs are also worthwhile to check out so let me go back to here and go full screen and Q&amp;A. Yeah. <br>[35:37] Hamel: So, one question is, will Inspect be integrated with pre-existing POSIT products like RStudio or anything else? <br>[35:46] JJ Allaire: So, just to clarify, Inspect is not a POSIT project. It‚Äôs a UK AI Safety Institute project. So it will not. I mean, unless it‚Äôs just in a separate‚Ä¶ Exist in a parallel universe. So‚Ä¶ We have a VS Code extension, but I‚Äôm not sure about any other positive things. <br>[36:10] Hamel: Yeah. I think I definitely know the answer to this question, but I‚Äôll just go ahead and ask it because it‚Äôs a question. Does Inspect support evaluating LLM systems using the inputs and outputs that was produced in the past? <br>[36:26] JJ Allaire: Yes. Yes. You mean you‚Äôre talking about some kind of‚Ä¶ <br>[36:31] Hamel: Like past logs. <br>[36:32] JJ Allaire: Yeah, yeah. So what you can do is the input can be oversimplified. Input can be a prompt or it can be a message history. So you could replay an entire message history. And so you could take, like you said, a past log and then construct a new data set that would allow you to evaluate using the previous prompts. <br>[36:53] Hamel: Okay. Another question is, does the inspect team‚Ä¶ plan to expand? It might be good to maybe briefly describe what is the inspect team or who‚Äôs working. But does the inspect team plan on expanding the list of metrics to include stuff like MRR? and Mars like a ranking metric? <br>[37:14] JJ Allaire: Yeah, we will, yes. The metrics, the built-in metrics are a little spare, partly because a lot of people do end up writing their own metrics. But I think there are ones that are like definitively important and common. And so we will definitely be doing that. And then the inspect team is, there‚Äôs two or three of us who work on it, working on it full time. But there‚Äôs a lot of people. inside UK AI Safety Institute who provide pull requests and design feedback and things like that. It‚Äôs sort of like just like eval. <br>[37:48] JJ Allaire: It‚Äôs like it‚Äôs just evals are everywhere. And so it‚Äôs kind of in the air. And so there‚Äôs a lot of feedback and a lot of a lot of iteration. And then we‚Äôve got I definitely have the bandwidth to to advance the project at a significant pace. <br>[38:05] Hamel: It‚Äôs great. I guess like this is a good time to ask the next question, which is. What is the future expectation for Inspect? Will it continue to be developed for the long term? What will its direction be dictated by the UK government or the community or both? And how do you think that‚Ä¶ Yeah, <br>[38:20] JJ Allaire: it‚Äôs a good question. It‚Äôs definitely going to be developed for the long term. We view it as like a foundational piece for doing sophisticated and complex evaluations. And I think, I expect that if it does get picked up more broadly by lots of other players, that there will be community discussion and consensus about what‚Äôs important. And we definitely don‚Äôt, we would not have open sourced it if it was like, oh, this is just like something we‚Äôre using. Oh, by the way, here, everyone else can use it too. <br>[38:52] JJ Allaire: I think we want to make it broadly useful for all the different sorts of evaluations. One of the ideas is that if we can kind of level up the quality of evaluations more broadly, I think that‚Äôs just a better world to be in where everybody does evaluations better. And so I think we‚Äôre quite interested in making it work for lots of different use cases and scenarios and actors. <br>[39:23] Hamel: Okay. Does inspect allow for using logs from an API or database query, or is it strictly files only? <br>[39:32] JJ Allaire: So, using logs or writing logs? I wonder. <br>[39:38] Hamel: Using logs. <br>[39:41] JJ Allaire: Yeah, I mean, the‚Ä¶ We use FSSpec, so logs can come from any file system that is addressable by FSSpec. I think if you had an API where the logs were, you would interact with the API, you‚Äôd realize that on the local file system, and then you‚Äôd‚Ä¶ interact with it. We have an internal abstraction for logs, a log recorder that is not just doesn‚Äôt presume that it‚Äôs a JSON file. And so maybe we may add other recorders that can, you know, log to databases and things like that. But Yeah. <br>[40:20] JJ Allaire: The other thing is we want the log file format to be something you can compute on. So we do, we actually publish, you can see in the docs, we publish a JSON schema for it. We publish TypeScript binding types for it. So, you know, we want it to be something that people can use and compute on. And obviously a Python API for it. <br>[40:43] Hamel: All right. I‚Äôm just scrolling through the questions here. Someone is really curious about the cybersecurity eval stuff. So the question is, can you say a little bit more about the Docker-based cybersecurity CTF eval? Do you envision shareable suites of security tests? <br>[41:00] JJ Allaire: I think that‚Äôs going to happen. Yeah, we haven‚Äôt shared any of ours. I do know other people are talking about making shareable suites of security tests. Like there‚Äôs other people in the ecosystem who are planning on open sourcing those sorts of things. So that‚Äôs definitely part of the plan. And we‚Äôre going to, we‚Äôve figured out, like people inside UK AI Safety Institute sort of like figured out how to do the Docker thing without, they just bootstrapped it inside the existing solver idea. <br>[41:32] JJ Allaire: But we‚Äôre actually going to have a more formal construct to support what we call tool execution environments that will, you know, will do more of the Docker heavy lifting and interacting with Docker Compose and things like that. That‚Äôll be more built into the framework in the future, in the not too distant future. If you went to do it now, you might say, huh, what am I supposed to do? But I think in a month or two, it‚Äôll be more clear and documented and a happy path. <br>[42:04] Hamel: Let‚Äôs see. My team is using weights and biases to track eval metrics. Is there a way to combine inspect AI with weights and biases? We are‚Ä¶ <br>[42:15] JJ Allaire: open to do that. That‚Äôs on the fairly short list of things that we want to do. I haven‚Äôt looked carefully at the weights and biases API and how rich we can make it, and hopefully we can make it quite rich. I know that they have some kind of API I saw where you can have an iframe in their thing, so we could potentially even have the log viewer go embedded in weights and biases that also project a bunch of the log file results into it. into the standard weights and biases affordances. <br>[42:46] JJ Allaire: So we‚Äôre going to be looking at that in the next couple, three, four months, hopefully. <br>[42:55] Hamel: Someone asked a question. They‚Äôre really curious about the design philosophy behind this, like where you got the inspiration from. They said it‚Äôs very clean, and the clarity of thought is impressive. <br>[43:07] JJ Allaire: It‚Äôs all Hadley all the time. <br>[43:10] Hamel: Okay. <br>[43:12] JJ Allaire: I learned a lot from him. I‚Äôve seen a lot of his work. When I‚Äôm designing a framework, he didn‚Äôt provide direct feedback on this, but he‚Äôs like the virtual sitting on my shoulder, keeping me accountable to keeping things clean, and simple, and straightforward, and composable. <br>[43:36] Hamel: That‚Äôs great. One more person is asking, can Inspect be used with LLM proxies, like light LLM? I don‚Äôt see why not, <br>[43:44] JJ Allaire: but‚Ä¶ <br>[43:48] Hamel: Absolutely, yeah. Okay. Someone is asking about, do you have any imports or plug-ins for using Mac GPUs locally within SPECT AI? <br>[44:02] JJ Allaire: So, yes. So you can use whatever Oyama is doing, which runs on the Mac. I‚Äôm sure that they‚Äôre using Metal and things to make inference reasonable. I‚Äôm not positive, but I can‚Äôt imagine that a project like that wouldn‚Äôt be using Mac GPUs. So, Oyama is one way. And then you can, with Hugging Face, use the MPS backend. We do have support for that. So that, I feel like the Oyama has done a better job, like, reducing the memory requirements maybe than, I mean, depends on the Hugging Face model. <br>[44:42] JJ Allaire: But we found a lot of, like, the Hugging Face models that you want to evaluate, you know, you definitely need to have, like, pretty reasonable GPU or GPUs. So, and I don‚Äôt know how generally, how good like PyTorch MPS is. I don‚Äôt know like how good it is. <br>[45:04] Hamel: I think this kind of may be a good stopping point. There‚Äôs certainly other questions, but I think we hit the most important ones as far as I can see. <br>[45:17] JJ Allaire: Okay. <br>[45:18] Hamel: Terrific. What do you recommend for people trying to follow your work? Like how to keep in touch with you or appraised of what you‚Äôre working on? <br>[45:30] JJ Allaire: Yeah. Yeah. i‚Äôm not i do have i have a twitter presence but i don‚Äôt i‚Äôm not like posting on there all the time so that‚Äôs not a great place github is a perfectly good place to to stalk and see and see what‚Äôs going on um you know um some of these commits don‚Äôt show up like for inspect don‚Äôt show up there but but some of this like peripheral work like this workshop show up there so yeah i‚Äôd say follow follow me on github it‚Äôs a good way to go okay great yeah <br>[46:04] Hamel: All right. With that, thank you, JJ. It‚Äôs really great to have you here. I learned a lot about the framework as well. So it was great to have this overview. <br>[46:14] JJ Allaire: All right. Yes, it‚Äôs a privilege to be able to come and talk to everyone here. And so hopefully you‚Äôll have for those that decide to give Inspect a try, hopefully you‚Äôll have success with it. And let us know if you don‚Äôt. And we‚Äôll be very active on GitHub issues. So please let us know what‚Äôs wanting and or what you aspire to do that you can‚Äôt do. <br>[46:35] Hamel: All right, great. Thank you. <br>[46:37] JJ Allaire: Thanks, JJ.</p>
</div>
</div>
</div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = true;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "Óßã";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/parlance-labs\.com\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/HamelHusain">
      <i class="bi bi-twitter" role="img">
</i> 
    </a>
  </li>  
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/hamelsmu">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
</ul>
    <div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/parlance-labs/website/edit/main/education/evals/allaire.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li></ul></div></div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>