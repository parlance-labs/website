<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2024-07-30">

<title>FSDP, DeepSpeed and Accelerate – Parlance</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../b.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark.min.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-QXGQ6F7NKT"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-QXGQ6F7NKT', { 'anonymize_ip': true});
</script>
<style>html{ scroll-behavior: smooth; }</style>


<link rel="stylesheet" href="../../styles.css">
<meta property="og:title" content="FSDP, DeepSpeed and Accelerate – Parlance">
<meta property="og:description" content="Advanced techniques and practical considerations for fine-tuning large language models, comparing tools, discussing model precision and optimization, and exploring best practices for effective training and deployment.">
<meta property="og:image" content="https://parlance-labs.com/education/fine_tuning/zach.png">
<meta property="og:site_name" content="Parlance">
<meta property="og:image:height" content="360">
<meta property="og:image:width" content="640">
<meta name="twitter:title" content="FSDP, DeepSpeed and Accelerate – Parlance">
<meta name="twitter:description" content="Advanced techniques and practical considerations for fine-tuning large language models, comparing tools, discussing model precision and optimization, and exploring best practices for effective training and deployment.">
<meta name="twitter:image" content="https://parlance-labs.com/education/fine_tuning/zach.png">
<meta name="twitter:creator" content="@HamelHusain">
<meta name="twitter:site" content="@HamelHusain">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image-height" content="360">
<meta name="twitter:image-width" content="640">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Parlance</span>
    </a>
  </div>
          <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../services.html"> 
<span class="menu-text">Services</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://hamel.dev"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../team.html"> 
<span class="menu-text">Team</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../education/"> 
<span class="menu-text">Education</span></a>
  </li>  
</ul>
          <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
            <div id="quarto-search" class="" title="Search"></div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#chapters" id="toc-chapters" class="nav-link active" data-scroll-target="#chapters">Chapters</a></li>
  <li><a href="#resources" id="toc-resources" class="nav-link" data-scroll-target="#resources">Resources</a></li>
  <li><a href="#slides" id="toc-slides" class="nav-link" data-scroll-target="#slides">Slides</a></li>
  <li><a href="#full-transcript" id="toc-full-transcript" class="nav-link" data-scroll-target="#full-transcript">Full Transcript</a></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/parlance-labs/website/edit/main/education/fine_tuning/zach.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li></ul></div></nav>
    <div class="quarto-margin-footer"><div class="margin-footer-item">
<button onclick="window.location.href='https://hamel.ck.page/7d15a4b6e7'" style="background-color: #C75C56; color: white; padding: 12px 24px; border: none; border-radius: 6px; font-size: 16px; cursor: pointer; transition: background-color 0.3s ease;">
Subscribe To Our Newsletter
</button>
</div></div></div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">FSDP, DeepSpeed and Accelerate</h1>
  <div class="quarto-categories">
    <div class="quarto-category">fine-tuning</div>
    <div class="quarto-category">llm-conf-2024</div>
  </div>
  </div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">July 30, 2024</p>
    </div>
  </div>
  
    
  </div>
  
<div>
  <div class="abstract">
    <div class="block-title">Abstract</div>
    <p>Advanced techniques and practical considerations for fine-tuning large language models, comparing tools, discussing model precision and optimization, and exploring best practices for effective training and deployment.</p>
  </div>
</div>


</header>


<div class="quarto-video ratio ratio-16x9"><iframe data-external="1" src="https://www.youtube.com/embed/TrnJG_ve6R0" title="" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div>
<div class="mobile-only callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Subscribe For More Educational Content
</div>
</div>
<div class="callout-body-container callout-body">
<p>If you enjoyed this content, subscribe to receive updates on new educational content for LLMs.</p>
<center>
<script async="" data-uid="6379a28bdb" src="https://hamel.ck.page/6379a28bdb/index.js"></script>
</center>
</div>
</div>
<section id="chapters" class="level2">
<h2 class="anchored" data-anchor-id="chapters">Chapters</h2>
<p><strong><a href="https://www.youtube.com/watch?v=TrnJG_ve6R0&amp;t=0s">00:00</a> Axolotl vs.&nbsp;Hugging Face AutoTrain</strong><br>
Zach discusses the differences between Axolotl and Hugging Face AutoTrain.</p>
<p><strong><a href="https://www.youtube.com/watch?v=TrnJG_ve6R0&amp;t=126s">02:06</a> Becoming an Effective LLM Engineer</strong><br>
Zach emphasizes the importance of hands-on experience in training models for effective learning.</p>
<p><strong><a href="https://www.youtube.com/watch?v=TrnJG_ve6R0&amp;t=433s">07:13</a> Getting Feedback from Experts</strong><br>
Participants explore ways to reach out to experts for valuable feedback.</p>
<p><strong><a href="https://www.youtube.com/watch?v=TrnJG_ve6R0&amp;t=584s">09:44</a> Datasets for Finetuning LLMs</strong><br>
Discussion on the use of synthetic data, Hugging Face datasets, and other sources for fine-tuning LLMs.</p>
<p><strong><a href="https://www.youtube.com/watch?v=TrnJG_ve6R0&amp;t=863s">14:23</a> Advantage of FSDP</strong><br>
Zach explains how FSDP was crucial for fine-tuning LLama 3 across multiple GPUs.</p>
<p><strong><a href="https://www.youtube.com/watch?v=TrnJG_ve6R0&amp;t=922s">15:22</a> Advantages of Using torch.compile</strong><br>
Torch.compile is highlighted as an optimization tool beneficial for both inference and training due to its dynamic operator fusion capabilities.</p>
<p><strong><a href="https://www.youtube.com/watch?v=TrnJG_ve6R0&amp;t=1054s">17:34</a> Training Inference Precision</strong><br>
Zach talks about the challenges of training models in bf16 precision.</p>
<p><strong><a href="https://www.youtube.com/watch?v=TrnJG_ve6R0&amp;t=1158s">19:18</a> Downsides of FSDP</strong><br>
Techniques like FSDP are crucial for running training or inference when the model is larger than the VRAM of a single GPU. Deepspeed is an FSDP alternative that offers more flexibility.</p>
<p><strong><a href="https://www.youtube.com/watch?v=TrnJG_ve6R0&amp;t=1524s">25:24</a> Fine-tuning vs.&nbsp;Frontier Models</strong><br>
Discussion on the possibility of fine-tuned models beating frontier models.</p>
<p><strong><a href="https://www.youtube.com/watch?v=TrnJG_ve6R0&amp;t=1647s">27:27</a> Ensuring Proper Model Functioning During Inference</strong><br>
Zach advises using the Hugging Face pipeline to test the finetuned model to ensure proper behavior.</p>
<p><strong><a href="https://www.youtube.com/watch?v=TrnJG_ve6R0&amp;t=1791s">29:51</a> Running 8 Billion Parameters Model on a 4090</strong><br>
Participants discuss techniques like AWQ, TRTllm, and vLLM for running large models locally.</p>
<p><strong><a href="https://www.youtube.com/watch?v=TrnJG_ve6R0&amp;t=1861s">31:01</a> Training Models in INT-8</strong><br>
Training in INT-8 and fp8 is unstable, leading to the preference for bf16, though some companies are exploring fp8.</p>
<p><strong><a href="https://www.youtube.com/watch?v=TrnJG_ve6R0&amp;t=2070s">34:30</a> Accelerate Failure Case</strong><br>
Zach discusses the robustness and resilience of Accelerate in demanding workloads using thousands of GPUs.</p>
<p><strong><a href="https://www.youtube.com/watch?v=TrnJG_ve6R0&amp;t=2158s">35:58</a> Relevance of Chinchilla Scaling Laws</strong><br>
Chinchilla scaling laws remain relevant, and extended training offers significant benefits.</p>
<p><strong><a href="https://www.youtube.com/watch?v=TrnJG_ve6R0&amp;t=2302s">38:22</a> Relevance of TensorFlow</strong><br>
Despite its decline in popularity, TensorFlow is still supported by transformers, and there is a discussion on the future of JAX.</p>
<p><strong><a href="https://www.youtube.com/watch?v=TrnJG_ve6R0&amp;t=2510s">41:50</a> Training on Apple Silicon</strong><br>
Apple Silicon is suitable for inference but not ideal for training, with NVIDIA GPUs being recommended.</p>
<p><strong><a href="https://www.youtube.com/watch?v=TrnJG_ve6R0&amp;t=2718s">45:18</a> Serving Multiple LoRAs with Accelerate</strong><br>
vLLM and LoRAX can be used to serve multiple LoRAs.</p>
<p><strong><a href="https://www.youtube.com/watch?v=TrnJG_ve6R0&amp;t=2936s">48:56</a> Mixture of LoRAs</strong><br>
A discussion on using LoRAs in a mixture setting with a router.</p>
<p><strong><a href="https://www.youtube.com/watch?v=TrnJG_ve6R0&amp;t=3095s">51:35</a> Deciding on a Fine-tuning Project</strong><br>
Zach suggests recreating existing solutions for various problems as a good starting point, emphasizing learning from both successes and failures.</p>
<p><strong><a href="https://www.youtube.com/watch?v=TrnJG_ve6R0&amp;t=3199s">53:19</a> Choosing Model Sweet Spot</strong><br>
Zach recommends choosing a model based on available VRAM, while Hamel suggests using the smallest model that achieves the desired performance. Dan highlights the importance of considering inference cost over training cost.</p>
<p><strong><a href="https://www.youtube.com/watch?v=TrnJG_ve6R0&amp;t=3511s">58:31</a> Phi-3’s Popularity for Finetuning</strong><br>
Zach discusses the Phi-3 model’s lack of real-world performance, making it less popular for fine-tuning.</p>
</section>
<section id="resources" class="level2">
<h2 class="anchored" data-anchor-id="resources">Resources</h2>
<p>Links to resources mentioned in the talk:</p>
<ul>
<li><a href="https://huggingface.co/spaces/muellerzr/llm-conf">Scaling model training with more compute, how do they do it?</a> : Presentation on scaling model training.</li>
<li><a href="https://huggingface.co/docs/accelerate">Accelerate docs</a>: Documentation for Accelerate.</li>
<li><a href="https://huggingface.co/docs/accelerate/quicktour">Accelerate Quicktour</a>: Quick tour of Accelerate.</li>
<li><a href="https://huggingface.co/docs/accelerate/en/concept_guides/fsdp_and_deepspeed">FSDP vs DeepSpeed</a>: Comparison between FSDP and DeepSpeed.</li>
<li><a href="https://github.com/huggingface/accelerate/tree/main/examples">Accelerate Examples</a>: Examples for using Accelerate (recommend starting with <code>nlp_example</code> then exploring <code>by_feature</code>).</li>
<li><a href="https://huggingface.co/spaces/hf-accelerate/model-memory-usage">Memory estimator</a>: Tool for estimating model memory usage.</li>
<li><a href="https://huggingface.co/spaces/Vokturz/can-it-run-llm">Can I run it LLM edition, also talks about LoRa (inference focused)</a>: Discussion on running LLMs and LoRa.</li>
<li><a href="https://huggingface.co/spaces/cllatMTK/TransformerAnalyzer">TransformerAnalyzer</a>: Detailed estimator showing FLOPS and other parameters.</li>
</ul>
</section>
<section id="slides" class="level2">
<h2 class="anchored" data-anchor-id="slides">Slides</h2>
<p><object data="zach.pdf" type="application/pdf" width="100%" height="600"><a href="zach.pdf" download="">Download PDF file.</a></object></p>
<p><br></p>
</section>
<section id="full-transcript" class="level2">
<h2 class="anchored" data-anchor-id="full-transcript">Full Transcript</h2>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-2-contents" aria-controls="callout-2" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Expand to see transcript
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-2" class="callout-2-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p><br>[0:03] Dan Becker: What are your feelings on Axolotl versus HF Autotrain? <br>[0:10] Zack Mueller: There’s a wink emoji. Who is this? Because it’s either my coworker or you know who from Axolotl. They solve two different problems in a way, right? Autotrain is agnostic in the sense of like train whatever you want with the data you have. And it’s also a slightly different API with what it looks for. And axolotl is very high level, train a model for basically text right now, as Wing was talking about earlier. Do it quickly, do it fast, following a pretty loose guideline towards what you can fit. <br>[0:53] Zack Mueller: So there are two different solutions to a problem that can have overlap. <br>[1:02] Dan Becker: if that makes sense i’ve never used hf auto trade so i was actually i prioritized this question because i was hoping to learn and i think i did uh what hf auto or hiking face auto train actually does through your answer um and i personally did that it almost sounds like is auto train really doing more of like the smart search of parameters part of the problem uh oh boy <br>[1:32] Zack Mueller: Oh, the auto train talk soon will be more because I don’t know. My extent of auto train is helping debug auto train when accelerator So that would be a good question to save for the auto train talk is my official answer. <br>[1:55] Dan Becker: Great. I’ll count that one is answered and I’ll let you start picking some. <br>[2:01] Zack Mueller: Sure. Since many of us are new to LLM fine tuning, how do you think the typical learning journey looks like until one becomes an effective LLM engineer? Just tweak with shit. Like just play with code, build models, do things. Because you can spend ages reading and reading and reading and reading and never touch code. And someone who’s just in their backyard doing these things for fun on the side will have more practical experience. <br>[2:32] Zack Mueller: That sort of what’s the situation three or four years ago when I was learning fast AI, and I still believe that situation today. Train models, get comfortable with the code. The depth of expertise will come with respect to the amount of time you do it. Even if it’s just running the same axolotl command and just looking at the weights and biases graph for different data sets, you will learn something there that I probably won’t because… I haven’t done that enough yet. <br>[3:05] Zack Mueller: So just start playing with things and sort of the same advice that we started giving with Fast.ai back in the day. Make it public, make your learnings public, you know, your models available, your teachings available, and be open to criticism from the people that know a lot more than you to learn from it and be very humble in that regard, is I guess my answer to that. <br>[3:32] Dan Becker: I want to push back for a moment just to hit, like, maybe there’s something interesting in this. And that is when you are just fiddling, which I quite like doing, you learn by seeing what works or what happens and what doesn’t happen. And if we were doing, there are many domains and conventional machine learning is probably a great example where you try something, your score goes up or it goes down and you’re like, oh. this improved it or it didn’t improve it. <br>[4:04] Dan Becker: And with generative AI use cases, and I think language in particular, sometimes you can see what happened to your perplexity score, but it’s a little hard to know, like, do I like what just happened? Or like, what did just happen when I, I don’t know, changed my learning rate or changed whatever. Do you have any thoughts about how one gets feedback as they’re experimenting in order to make sure they’re learning? <br>[4:42] Zack Mueller: Yeah. Talk to the people that are doing the cool things. Just send them a DM and say, hey, I’m doing this. I don’t understand what this particular graph means or post it on Twitter. If you go through my last Twitter feed from the last month, I’m pretty sure I made a tweet that was quite literally just Hey guys, here’s my loss graph. Does this seem normal? And because if you’re only judging yourself and going off of yourself and your own knowledge, you’re going to think everything’s fine because everything looks normal, right? <br>[5:17] Zack Mueller: And so that’s where communities really matter, especially like this community that is now forming, because we’re all here to go learn this thing, right? So we can all sit there and go, hey, here’s my graph. What are your thoughts? <br>[5:32] Hamel Husain: And I think it’s also important to pick a small project. It’s really good if you have an LLM production already and you have some traces, you have some logs about how your LLM is responding and what the user is asking and all whatever. We’ll go through that in the next lecture a little bit of how to collect those logs. But you can take those and just fine tune a model. And start with a smaller model. Start with LoRa. It’s actually kind of hard to. mess it up. It was like really nice. <br>[6:03] Hamel Husain: Like Laura in the pre-trained model use axolotl. You don’t really have, it’s not like a, it’s not, you have to get the hyperpresenters exactly right necessarily. Like it’s kind of has, yeah, it’s like kind of this random forest feeling where you just like point the model at the data and it kind of works. And if you get that positive reinforcement, it really helps if you get it fast. <br>[6:28] Zack Mueller: Yes. It’s easy. as I look at my graphs from the last week. <br>[6:34] Dan Becker: Yeah, <br>[6:35] Zack Mueller: you’re good. You’re good. <br>[6:37] Dan Becker: I was going back to our talk from when we were with Wing. Parts of it might be easy. The part that’s hard is actually dealing with tokenization and prompts and making sure that you do the same thing at inference time as training time. And that is like the opposite of… That’s very hard. <br>[6:58] Zack Mueller: I think what I spent the last hour making sure that I could get my prompts right for inference after doing my axolotl training. So it’s a learning curve and some of it’s easier than others, but that’s part of the game. <br>[7:11] Dan Becker: There was a question in Discord, which was, and I want to say one thing before, then I’ll hand it to you guys for an answer, which was, Uh, something like where do all the cool people hang out that I can use to get feedback? Um, I think that despite the immense amount of hype, the community of people who are actively like doing stuff and sharing it, even like community of doing it, people who are doing interesting things is smaller than you would expect and is sort of in its infancy. <br>[7:48] Dan Becker: And as a result, the ability to get feedback is much, much greater now than it will be. a year from now when there’s more people doing it and then it’s harder to get people’s attention. <br>[8:00] Dan Becker: And so we could talk about Twitter and I think our Discord, a bunch of places that you can think of, but I just want to say, I think it is a huge, huge opportunity for us to, if I can sound like a salesman for a moment, to get in on the ground floor by which I mean, people are not, people who do cool stuff like Zach are not so inundated that they probably refuse. <br>[8:25] Zack Mueller: messages from anyone or anything like that no this community like it’s been a very humbling experience because i sort of wasn’t doing community stuff for a bit that it’s we’re all people you know and a lot of us don’t have egos and especially right now while it’s a fine group of people like you were saying make use of that you know talk to the peoples that are coming out with these models and evals and ask them questions in twitter dm on their responses More likely they’ll not, they’ll answer whatever your question is, as long as <br>[8:57] Zack Mueller: you like phrase it right. And don’t, you know, give them not enough information. <br>[9:02] Zack Mueller: That’s a, <br>[9:03] Hamel Husain: but you definitely should put in the work. So like, don’t just like, don’t just DM someone like whatever, like, you know, like tell them what you tried, what didn’t work, what you researched, but then you got stuck, like show the person that you are trying. So from time to time, I’ll get a DM from someone that they just. didn’t try to like read the documentation read their error message read anything and in that case many times i have to ignore those um so don’t don’t be that person uh <br>[9:44] Charles Frye: i’d be actually super interested to hear zach’s answer to one of the most upvoted questions which are like what are some good public you data sets or Kaggle challenges for training or fine tuning LLMs. Like the Titanic data set or Iris or Penguins or whatever, but for LLMs. <br>[10:02] Zack Mueller: That’s a good question that I’m not 100% sure on the answer for, and I’ll sort of explain a little why. So my Lama 3 fine tune is based off of the StarCoder 2 self-instruct paper. And essentially what that is, is using an LLM, using the base LLM to generate your completion dataset for you off of existing code on GitHub on a dataset called the stack. <br>[10:30] Zack Mueller: So like Personally, if I were to choose a starting data set, that one’s not terrible because you’re generating it yourself or you have them available with known benchmarks that have end-to-end full transparent pipelines. So you know what’s good, you know what’s bad, and you know roughly where you should end. That’s at least one that I know of that I’m currently doing to learn. But I’d be very interested to know what you guys sort of also use as a gateway sort of data set and problem. <br>[10:57] Hamel Husain: I like the instruction tuning one a lot, the Phil Smith. I don’t know if I’m pronouncing his last name correct. Whatever. Like Phil Schmidt, he has like a fine-tuning Lama blog post. I think instruction tuning is a really good gateway because it kind of like gets your mind ready for fine-tuning. <br>[11:20] Zack Mueller: 100%. There’s a ton you can learn in that. Let’s see. What was… <br>[11:30] Dan Becker: The other… need to put together demos for potential clients somewhat frequently. And if you just go to Hugging Face and do a dataset search, like if I wanted a dataset about discussion of chemistry topics, I can probably find one. And then it’s probably in a standard format. And then I just drop that link in the axolotl config. I would say that the same way that Kaggle used to be and maybe still is for tabular data sets, the breadth of what’s in Hugging Face data sets is pretty great. <br>[12:14] Charles Frye: Yeah. One thing I would say is that synthetic data is really nice for, like, one, there’s a practical use, which is taking a model that’s too expensive to run and getting it into a smaller model. And then two… <br>[12:29] Charles Frye: you have a very clear data generating process that you’re trying to mimic and you can run it right if you have a data set you got from uh the internet you can’t like generate new data from that on the fly ad hoc and that’s really important for like testing whether your training is working or not um so uh yeah and you so you can always compare it to this executing this like model you can also execute so that’s maybe you run inference in a 70b model and you’re fine tuning an eight B or a 3B <br>[12:59] Charles Frye: model. And you have a really solid gold standard because all you’re trying to do is mimic that thing. And then the second piece of info, the second advice is that you also want something that changes over time, like the data set grows over time. Because when it comes time to actually deploy machine learning in production, you’re going to have like a stream of data, not like a batch data set that you just run on. And so if you want something, so you like, just for example, you might take tweets and have GPT-4 classify them. <br>[13:37] Charles Frye: And that’s your data set. And then a week later, there will be more tweets that you can run through GPT-4 and classify. And now you can find out whether you have like train test leakage issues. You can find out if you’re like overfitting to the to the like this week’s content of tweets. And next week, it’s something different. And that, so it’s like kind of similar to Numeri or some of the like ongoing challenges where you need to like actually learn, you know, of like a, how to model a stream of data. <br>[14:07] Charles Frye: And that also is going to really help you know what you need to do when it’s time to build a production ML application. <br>[14:21] Zack Mueller: Let’s see. One of the questions I was interested in, in my experience, it’s been a pain either to use accelerate or torch. Can you clarify the best practices when using it? And is it worth using it when running DDP, FSDP or deep speed? I just remember when torch compile launched, it was all hype. But then there was no example in Excel all these compile. And does it have any benefit for VRAM? Yes, I would not be able to do my llama three billion fine tune on 240 90s if I did not have FSDP available. <br>[14:52] Zack Mueller: Because essentially what FSTP allows is your 24090s are not two 24 gig cards. They are, in a light sense, 148 gigs. And so it’s critical that you do that, which go back through the talk. I’m pretty sure I talked very explicitly about the difference in memory usage between the three of those. Let’s see. <br>[15:22] Charles Frye: I guess the question was also kind of about Torch compile, if I understand it right. It was like using Accelerate with compile, using Axolotl with compile. And I guess my feeling is that. <br>[15:33] Charles Frye: compile is like a little bit more of an inference time optimization than a than a training time optimization where it’s like you have a very fixed graph you um like the maybe you’re at inference time often your batch sizes are much smaller um because you’re only getting like one request at a time and uh so the like overhead from running a dynamic graph generation is too high and so you’d rather just so you want to um switch to a static compiled graph. That’s my impression from how I’ve used the tools. <br>[16:09] Zack Mueller: That’s certainly how it used to be. That is not where PyTorch is going. PyTorch wants Torch compiled, which mixed, right? Because it’s compiled, it can have issues. For instance, they have a library called Pippi out right now that is native Torch pipeline parallelism for training. that relies heavily on Torch Compile. So that’s where things get weird and sort of experimental. And I expect that landscape to change dramatically over the next like three to six months. So for right now, I believe you can train on compile. <br>[16:51] Zack Mueller: How well it works, a lot depends on sort of how the model is laid out, I found, with just where people’s issues have come. <br>[17:00] Charles Frye: So the benefit of train time is that you’re getting dynamic operator fusion? <br>[17:05] Zack Mueller: Yes. So it feeds up train time. Mostly it’s throughput optimizations, more than memory optimizations. <br>[17:16] Charles Frye: Yeah, like kernel fusion? <br>[17:18] Zack Mueller: Yes. Yes. <br>[17:21] Charles Frye: Got it. <br>[18:08] Zack Mueller: BF16 Here’s sort of an interesting one. I have a question about training inference precision. I’m training on 3090s at home or thinking of renting an A100 on Azure. However, my inference setting T4s do not support BF16, but my trained model, trained based on DeepSpeak uses BF16 seems to work poorly in FP16. Any recommendation on here on how I can increase throughput? I would use vanilla Hugging Face inference, which has fake BF16. but the throughput is painfully slow. You’re gonna get painfully slow. You know, it’s, it’s, they’re optimized for for a very good reason. <br>[18:12] Zack Mueller: And that’s especially a scary place to be in because we had a lot of issues with models that were trained fully in BF16, which broke entirely when they were upcast to be to FP32 again. That’s why Trainer uses an autocast form to train everything in bf16 so that way it can uh be upscaled back easily so uh but normal fp16 is and same might come in and smack me for this but in my experience usually a little less uh optimized than bf16 will be so it will be slower Let’s see what else we have. <br>[19:17] Zack Mueller: Ah, I like this. I like anti-questions. What are the main downsides with FSTP? when is it really the not best tool for your job in training and fine tuning such as hardware configurations llms diffusions and vice versa uh basically fsdp really shines when you have you know big models when you’re training big models or if your model barely fits on one gpu and you have two available because now essentially what you can kind of do and imagine is the model is fully on one and the gradients and everything else are just in the other GPU. <br>[19:57] Zack Mueller: And so you have a ton of extra VRAM that you can go use. Now, FSTP versus DeepSpeed. DeepSpeed is a very configurable. It has a little more freedom than FSTP would when it comes to, like, offloading certain things and having certain device configurations. FSTP takes the all or nothing approach. So, like, I’m pretty sure DeepSpeed, you can specify, like, just these layers should be offloaded to, you know, the CPU. So that way we barely don’t hit out of memory. With FSTP, it’s all going to be done. So. <br>[20:32] Zack Mueller: It’s little situations like that where, does it all fit in memory? Use FSDV. If you have to do a little bit of offloading, might look at deep speed, be that 0.3 or 0.2, and see sort of what optimizations could go there. <br>[20:47] Hamel Husain: One question I have about that, and this is always the debate, is like, okay, if you’re GPU poor and using your own rig, there’s some fair amount of debate of like… <br>[21:02] Hamel Husain: does envy how much does envy link the the lack of envy link destroy performance and like if you had to google for this topic there’s very like sparse information there’s like there’s like one hugging face page where like sylvain did a experiment one time and sylvain and maybe even uh stas showed like some 25 degradation but then there’s some debate about okay that’s if that’s the right number and whatever. And then like, there’s a Tim Detmer’s blog who just flatly says that you don’t need it. <br>[21:38] Hamel Husain: And then there’s like other people are like, you do need it. Or like, it does like make a huge difference. So I’m just like curious if you like, yeah, I don’t, I don’t know the answer either. <br>[21:47] Zack Mueller: So it’s, NVLink doesn’t work for 30, for 49 days. And I believe maybe barely works for 30, 90s. I forget, but, um, <br>[21:59] Hamel Husain: That’s true. Yeah. So if you’re GPU poor, it would probably, yeah, yeah, yeah. It’s like you’re stuck in the 90s. Yeah. <br>[22:04] Zack Mueller: It’s only 3090s, which is why for a while, 3090s were sort of the golden child. I don’t have 3090s. I could find 4090s before I could find 3090s. That’s how insane it is. So the exact numbers on stuff like this is like, you know, Tim Detmers talked about how consumer cards are throttled a bit on purpose with their drivers. And NVIDIA knows about this. And so when I was doing the math recently to get like a new A4500 at the same VRAM as the 4090 was an extra $500, I think, five or 600. <br>[22:44] Zack Mueller: So it was like a tier up, because you’re already paying, you know, $1,800 for a, well, it was about the same ish. I think it was like 24 or 2500 for the A4500. If I had to build my rig again, I would probably buy the card. <br>[23:01] Hamel Husain: You would probably buy what card? <br>[23:03] Zack Mueller: I’d buy the A4500. Because it is a thing where like, more than the performance hit, the power usage. <br>[23:13] Hamel Husain: And the heat and everything, yeah. And the space. <br>[23:15] Zack Mueller: It’s a fraction. Yeah. Right? Like, I have two water-cooled 4090s, and I have to have a giant case because of it. Versus it, I could fit four A4500s in that case. I’m pretty sure. And because I think they’re single shot slot, if not, they’re too. Yeah, <br>[23:31] Hamel Husain: they’re very nice and slim. <br>[23:33] Zack Mueller: Yeah, they’re super slim. And they use like a fourth of the wattage. So and also they have more CUDA cores available to them for actually to be used by for training. However, if you can’t find them, which a lot of people can’t, you can get by, right? I’ve done my job. granted my job has had limited training but i’ve done my job with just two 40 90s to do four iterations on laura tuning uh llama 3 8 billion it’s about somewhere between four to six hours to get full training done yeah um it’s <br>[24:17] Hamel Husain: i think it’s a pretty good car yeah it’s a pretty nice yes card for sure like yeah it’s like small and yeah makes sense it works and it’s <br>[24:25] Zack Mueller: you know it’s one of those things where it’s like if you can find it i’d probably do it but if not like you’ll be okay it sucks because nvidia is sort of squeezing us out but yeah we’ll find a way they’re waging a war on the gpu ports it’s <br>[24:42] Hamel Husain: great we love it really bad um i like having the rig though oh it’s great for some reason like i just you Yeah, it’s kind of crazy. It’s 2024. I still like having a rig, but I still like having a rig. <br>[24:56] Zack Mueller: Well, it’s because you own it. You own it. I don’t know. <br>[25:00] Hamel Husain: It’s just like, it’s still a little bit easier for me to like tinker around. <br>[25:05] Zack Mueller: Yeah. And you know, you never get bored if you just sit there and upgrade computer parts every once in a while. Gives you a fun side hobby to do while you stare at the pretty fans. RGB or not? Let’s see. We want to know if fine tuning can ever catch up to frontier models. That’s a fun question. <br>[25:31] Hamel Husain: Well, if you look at Technium’s models, he has this community of fine-tunes and they like exceed the base on many benchmarks because he tries to fine-tune them broadly. It’s almost like a continued free training in a way from what he’s doing. <br>[25:46] Zack Mueller: Exactly. And so it’s largely on the community, right? And so if we can go through and make those fine-tunes and make them competitive, that’s great. In some ways, we’re also fighting a losing war because data, right? Because the closed source people have access to a ton more data than we do. But, you know, as you said, Hamill, we’re kind of keeping pace as best we can, you know? <br>[26:18] Zack Mueller: Also, notice this in the Discord, someone getting excited because they never heard about the A4500s before and the price, how it looks affordable because it’s close to the 3090. Make sure you’re looking at the right one. The older version is 20 gig. The new version is 24 gig. Either or, again, is fine in my opinion. I almost went with the 20 gigs instead of the 24 gigs. And I believe Sam actually recommended the 20 gigs for me instead of 4090s back in the day when I was building that. But here we are. <br>[26:49] Zack Mueller: I had to do some debugging with FP8, so I needed 4090s. <br>[27:02] Charles Frye: Wait, sorry, the A40, oh, the 4090s do have FP8, but the A4500s don’t because they’re Ampere series. Okay, yeah. <br>[27:10] Zack Mueller: The prior ones. There’s A4500s that are ADAs. <br>[27:16] Charles Frye: And they didn’t make it in H? <br>[27:18] Zack Mueller: Nope. <br>[27:20] Charles Frye: You hate to see it. <br>[27:21] Zack Mueller: So, but that’s the newer version. That’s the 24 gig that has the ADA capability. What are some ways to ensure that prompting and tokens work at… inference time. That’s a fun one. I was just looking at that. The best thing I found to do is upload your model to the hub or just have it locally and load it in a pipeline. And do, I believe it’s model.generate or even just calling the pipeline itself. There’s a phenomenal guide, which I will link here. Well, I guess I can’t link it there. I’ll link it in the discord. <br>[28:01] Zack Mueller: that talks about chat templating. And it was the exact debugging guide I used when I was looking at trying to find problems with inference when it came to taking these trained models and trying to look at how are my tokens looking? Let’s see. <br>[28:29] Hamel Husain: Yeah. I mean, the, the hugging face chat templates are pretty cool, but I don’t, I guess like, I actually don’t understand, like, can you use those directly in X lot? I’m not sure. <br>[28:41] Zack Mueller: No, you can’t. That was actually a big thing I was talking about with wing because X all doesn’t do that. And so you essentially have to copy and paste your entire chat template with the question you want to answer. which was very concerning for me because I felt like I was doing something wrong because I felt like that should be magical. <br>[28:59] Hamel Husain: Yeah, it does feel like the right design pattern in the future is like maybe standardizing on something like that, like the Hugging Face chat template. Maybe that’s what you’re advocating for in the Discord. <br>[29:12] Zack Mueller: Yeah, I was talking with him about that. And it’s like, that’d be a good thing at some point that even I might look at doing. Because that’s, you know, when you… merge your PEFT model, one thing I immediately wanted to do was test the weights to make sure that everything worked. So that’s huge. <br>[29:28] Hamel Husain: Yeah. And like, yeah, if you could do that, it would actually get rid of lots of spaghetti code. Because like a lot of the spaghetti code is around the prompt templating craziness. But the masking part, I don’t know the input output masking. Okay, maybe you can’t. Maybe it’s like, yeah. <br>[29:52] Zack Mueller: What I need to do to run inference on an 8 billion model using a single NVIDIA 4090. My current calculations show a minimum GPU requirement of 13 gigs. That’s about right. If you’re doing half precision, you can do quantize. You can also get a bit slow and do like offloading to offload onto the CPU. It’ll be a bit slower, but you can run it. And that’s just do device map equals auto whenever you’re like. <br>[30:26] Hamel Husain: bringing the model in from transformers yeah i mean like a user experience standpoint like sweet spot is i would say vLLM use auto awq or some quantization method like that and it’s a nice you know you can always like get faster with trt lm but then you have to like <br>[30:45] Zack Mueller: suffer i quickly fell in love with the llm that’s what the star coder to instruct people used for their data set generation it was like holy crap this is easy to use You just point to the folder and it goes. <br>[30:59] Hamel Husain: Yeah, for sure. <br>[31:01] Zack Mueller: Why aren’t models trained in int8? That’s a good question. Because it’s very unstable. NVIDIA has come out with something called Transformers Engine or, oh, there’s another one that I can’t remember off the top of my head. MS AMP. And they are experimental. You can train in 8-bit. Practically, from what I’ve heard just around the bend, is people have tried it, they still go back to BF16. It’s just better. That’s part of why I’m doing this Lama 3A billion experiment, is I want to go see it for myself. But that’s just what I’ve heard. <br>[31:42] Zack Mueller: I know PyTorch, though, is adding official support in. And so maybe they figured out some secret sauce with quantization on the fly plus native FP8. I don’t know. I haven’t looked too much into that repo yet, but I’m hoping that’ll change a bit in the future. For right now, it’s just not realistic from a quality perspective. <br>[32:08] Charles Frye: And that’s fair. You were answering that both for Int8 and for FP8, because you mentioned the transformer engine, which is FP8, not Int8, <br>[32:16] Zack Mueller: right? Yeah, it’s one of those weird things, right, where it’s Int8 for quantization or FP8. So I was answering… <br>[32:23] Charles Frye: for fp8 aka native 8-bit got it um and so yeah i’ve also heard what like reports from people about instability and difficulty using fp oh like yeah using fp8 which is why it’s like kind of surprising that they doubled down with fp4 with <br>[32:42] Zack Mueller: the blackwell architecture right like do you have any thoughts about that yeah i have thoughts how much of that i can say i don’t know you But it’s definitely interesting because clearly they have some sort of special sauce that lets them train models decently well. Because otherwise they wouldn’t be doing it. The thing that’s weird is we can’t necessarily recreate it, you know? Because otherwise everyone would be doing FP8 if it was truly as good as it was. So there’s some other stuff happening on the back end. I would love to know. <br>[33:20] Zack Mueller: it when the llama three paper finally comes out what they trained it because they have you know all those h100s which are optimized for fp8 um and so i would love to know if they actually were able to train it in fp8 well or if uh it wound up having to be you know bf16 which that’s a bit of a misnomer it’s bf16 with fp8 essentially So yeah, it’s definitely a wait and see sort of question. <br>[34:02] Hamel Husain: Amon wants to know if you can explain the difference between RLHFDPO and SFT. <br>[34:09] Zack Mueller: I cannot. I have not touched that library at all, sadly. but I think maybe one of my coworkers will be here that talks about it. I’ll double check the list, but at the very least, I know nothing about that. I’m sorry. <br>[34:28] Hamel Husain: I don’t know too much about that either, to be honest. <br>[34:32] Zack Mueller: What have you seen in terms of reasonable scale in applications and projects where Accelerate failed and what was missing that forced you to change or update Accelerate? Not a lot. So in the presentation, I mentioned how Lucid Rains uses accelerate for most of his projects he what he does is he recreates closed uh source papers in trainings and fully recreates them from scratch. And he’s orchestrating these on trainings of over 1,000 GPUs. Accelerate can’t fail, per se, because if Accelerate fails, all we are is a light wrapper around what everyone else is orchestrating. <br>[35:16] Zack Mueller: So it’d be very rare for Accelerate to fail in a few ways. The only thing I think I might have seen… is occasionally like weird timeout things and timeout issues that I still haven’t diagnosed the cause of and I’m still not 100% sure if it’s Accelerate because training and just distributed is just hard. You get weird issues that you don’t know the answer to that you got to go figure out. Your best advice is the experts at PyTorch, if not NVIDIA engineers. So that’s a good question. <br>[35:56] Charles Frye: There’s one I thought was interesting and I’d like to hear your take on it, Zach. Are the Chinchilla scaling laws still relevant and can we use it, them or other scaling laws to estimate which models will benefit the most from additional training? <br>[36:14] Zack Mueller: That’s a fun one because I’ve been mildly keeping an eye on that space. So for a while we thought, yes, right? Chinchilla scaling laws are sort of the end all be all. They still kind of are, except what Lama3 showed us and what all these other labs are showing us as well is you can still just keep training. You can still just keep training and do good. But I still think the scaling laws matter. <br>[36:43] Charles Frye: Yeah, I like the scaling laws tell you how to optimally allocate a fixed number of flops between parameters and data. And like for that, they are still. <br>[36:54] Charles Frye: like the there’s been like revisions and some window dressing around chinchilla but like for that they’re still correct but they do not tell you how to get the best model because the answer to get the best model is always to just continue training until it has converged right and so i but i think what’s maybe interesting for people who are doing continued pre-training and fine-tuning is that Some empirical evidence and most people’s intuition is that models that are under-trained, like Chinchilla models or the original Hoffman scaling law models, and anything but Lama 3, bottles that <br>[37:37] Charles Frye: are heavily under-trained should be more steerable and easier to fine-tune. Because there should be more slop in the weights. I don’t know to what extent, Zach, that has been your experience. <br>[37:49] Zack Mueller: No, I can agree with that thinking. I don’t have… <br>[37:51] Zack Mueller: comments on llama 3 yet the only comments i do know is when i was looking at my base checkpoints because i went actually a bit over in my path tuning compared to what i think you guys recommend because usually it’s like one to two iterations through the data and i trained for four if not five the fourth or fifth one showed the best while still improving my eval loss so at least for eight billion there might be some space there still but otherwise fully agree Is it fair to say that TensorFlow isn’t really relevant for <br>[38:24] Zack Mueller: any of this? Hugging face accelerate, etc. It seems like everything is built up by Torch now. Yes and no. TensorFlow and especially Keras is still very much a back end in Transformers. Support for it is, you know, yes, it’s died down a little bit, but now we have a few people that are working directly on it. And so starting to go back up. But yes, the general trend for the last few years has been PyTorch started out for research and then people just started preferring that framework a lot for a lot of things. <br>[39:05] Zack Mueller: No, I’m not going to say one is better than the other because they’re both equal. You know, it’s just everything I do is in PyTorch. That’s how I got started and I’m still in PyTorch. Kind of how it is. And I’m sure you guys feel mildly similar about that. <br>[39:22] Dan Becker: It seemed like Jax was going to gain a lot of popularity, and then I never hear people talk about it anymore. Is there much happening that you see in Jax? <br>[39:36] Zack Mueller: Kind of. The fun with Jax. <br>[39:39] Hamel Husain: The danger zone. Danger zone. Some person’s going to come in. <br>[39:45] Zack Mueller: Shoot me. You’re allowed to take me in the back room. It’s fine. It’s Google. At the end of the day, it’s Google. you know so take it with grain of salt they rewrite everything they do every few years you know, it depends. It’s a risk. It’s a gamble. And that’s sort of, I think, part of why people are hesitant to go use it. And also, I don’t know, it’s like with XLA. For a while, it was just on TPUs, and only researchers had access to TPUs. <br>[40:17] Zack Mueller: And so you didn’t really do a whole lot with XLA unless you were a researcher. And they’ve only recently brought it over to GPUs, and it works. It’s fine. It’s just weird, because I… wouldn’t have thought that they would have moved over to GPUs. So it’s kind of a situation like that of, it’ll be neat to see where it is in three years, if it’s still a thing in three years, and if it is, then that’s probably a good sign. Yeah. <br>[40:40] Charles Frye: I think also it is a very beautiful framework for thinking about, it’s not just an auto-differentiation framework, it’s like a program transformation framework. And so it’s like in some galaxy brain way, it’s like the right way. to do this. However, that makes it a lot harder to use. Like, like, it’s, it’s, you know, like pure functional programming when you get down to it. <br>[41:07] Charles Frye: And a lot of people who are researchers and tinkerers and data scientists are not comfortable with like, managing an RNG monad, you know, and like, Jax kind of like puts that stuff in your face. <br>[41:20] Hamel Husain: You just convinced me not to use it. <br>[41:24] Charles Frye: I don’t like that sort of thing. <br>[41:28] Hamel Husain: and will some of us enjoy the nerdy stuff i enjoy nerdy stuff too but i mean sometimes i mean yeah gotta pick and choose uh let’s see any <br>[41:45] Zack Mueller: other interesting ones uh any particular tips or limit trait limitations for training on apple silicon that’s a fun one um I can talk about this since PyTorch admitted it. Sumit tweeted about this last month. Silicon with PyTorch is okay. Inference, it’s great. Training, you’re looking at three different lower-end libraries that all try and do the same thing, each of them with varying degrees of success. One of them is PyTorches, and they have admitted that theirs is one of the worst ones. <br>[42:33] Zack Mueller: They’re looking to revamp that and get more into it and actually invest time in that in the next few months, I believe, Asuma said. So for right now, it’s good for inference, training. I’m sorry if you can hear my cat. Perfect. <br>[42:54] Hamel Husain: It’s not a big deal. Don’t worry about it. <br>[42:55] Zack Mueller: Okay. For training, it’s mixed. Take it with a grain of salt and try with an NVIDIA GPU if you have one. MacBooks are cool. I refuse to sign on to that. And so thankfully, I don’t have to sign on. <br>[43:11] Hamel Husain: Look, so much stuff can go wrong. I’m like, I’m just going to go the paved path here. I’m using NVIDIA GPUs, using Axolotl. Yeah. You know, something battle tested, like, because I don’t have time. Like, there’s so much stuff to do. Just barely have time to fix the data, usually. <br>[43:31] Charles Frye: Yeah, and I think it’s unlikely that Apple Silicon is going to become a preferred target for training because it’s like a system on a chip, CPU, GPU together. There isn’t something that looks like a server card with fast GPU interconnect. And additionally, on top of that, you need fast communication between each server blade. <br>[43:54] Charles Frye: and that’s just not something where apple has done work so like in 10 years we might be looking back at this the way somebody 10 years ago would have been like apple’s not making a gpu um you know apple’s not going to make their own hardware so like in the foreseeable future there is not the infrastructure in place to make it a really great target for training um so zach do you agree <br>[44:26] Dan Becker: We can’t hear. I didn’t hear what you said, Zach. <br>[44:28] Zack Mueller: Oh yeah, sorry. I muted my mic because Max was right here. The biggest sign of that, I agree with that. The biggest sign for me is if you’re not familiar with Cash on Twitter, who writes Dingboard, I love him. He’s phenomenal. He’s hilarious, but also has really good insights. He was this close to executing on like a cluster of the new Mac workstations to have the total VRAM usage. And then he said, no, actually, it’s much better if I just stick with the video. <br>[44:56] Zack Mueller: did a total 180 was about to buy it all and they went nope actually going with davidia because everything’s too unstable i think yeah similar story with george hotz right and the amd chips it’s like yeah yes amd is a whole different ball game but yes uh how would you serve multiple lauras with accelerate inference you’re not thinking about that how you could like hot swap lauras in and out I don’t think we’ve done that yet. I don’t necessarily know of anyone that’s done that yet. It’d be a neat problem. <br>[45:34] Charles Frye: Does VOM not have that? <br>[45:36] Zack Mueller: I don’t know. <br>[45:38] Charles Frye: You can load several Loras. Yeah, <br>[45:40] Hamel Husain: it does. You can? <br>[45:41] Zack Mueller: Oh, <br>[45:42] Hamel Husain: nice. It has a hot swap thing, kind of. You can go between Loras. It’s pretty cool. It’s like you let a new batch. <br>[45:48] Charles Frye: Or no. <br>[45:50] Hamel Husain: I didn’t try that part. <br>[45:51] Zack Mueller: Yeah. You’re slowly making me love it. <br>[45:54] Charles Frye: Yeah. <br>[45:54] Hamel Husain: But it’s really cool, actually. I can pull up the docs real quick, actually. <br>[45:58] Zack Mueller: Yeah, that’s fascinating, because that was a thought I had, I think, after the class on earlier this week, where I was like, huh, that’d be a fun experiment to see if we could go do. Someone go do that, document it, and write a blog. Tell us what happens. <br>[46:15] Dan Becker: I think that Lorax does that. <br>[46:21] Hamel Husain: OK, so you see this one? So basically, using lower adapters, and then you can. You can serve lore adapters. Just a second. Yeah, so you like these lore requests. You can have different adapters. I don’t know about how you would hop. Yeah, I guess because you already, yeah. You can just at inference in the generate, you can just decide to pass in a different adapter. <br>[46:55] Hamel Husain: apparently did you click that multi-lora inference.py file yeah i remember like looking at this in the past and not quite figuring out whether they would be hot swapped yeah process yeah i don’t know i haven’t tried this yet maybe it’s not hot swapped maybe i just not remembering yeah we’d have to go into because like they’re sort of saying it’s like as though it’s a separate model and i don’t know like separate i guess like you’re calling you’re not uh so like you’re loading the model separately yeah you see And then it’s only in the <br>[47:28] Hamel Husain: whatever forward pass that you are then passing the adapter. So I guess that’s hotspot. I might not know that. Maybe I’m just like assuming what the word hotspot means. <br>[47:40] Hamel Husain: I mean, <br>[47:41] Charles Frye: there’s like there’s like versions where you need to merge it into the model weights. And that’s, you know, that’s fine. It’s nice to not have to merge it in the model weights because it’s just like easier to manage the artifacts. And then the next optimization on top of that is as a batch is going through, you route some rows in the matrix through different loras. And that’s the really cool thing about loras, especially if you’re serving many people’s fine-tunes. You have a fine-tune for every user, you have a fine-tune for every region, whatever. <br>[48:14] Charles Frye: It’s great to just have your batches just get collected together, and you get most of the throughput benefit of the… of… <br>[48:21] Charles Frye: batching for the large model with all the customization of laura’s um so that’s that’s the like full um like per request laura um parallelization that you really like that’s why that’s why it’s so nice to have these like these parallel adapters like laura instead of sequential adapters like um like replacing the language model head or uh or like putting an adapter at the end of every linear layer or whatever makes <br>[48:47] Hamel Husain: sense Don’t pay attention. I was just scrolling around. <br>[48:55] Charles Frye: Yeah. Somebody asked about mixture of Laura. I don’t know if that’s, I guess that would be like live routing between Laura’s like they were experts. I don’t know if I haven’t heard of that being used. <br>[49:09] Hamel Husain: That was like a fun idea. <br>[49:11] Charles Frye: Yeah. I guess, yeah, you need to train them together the way you train experts together. <br>[49:19] Zack Mueller: because you need a like routing between each one well didn’t like what was the kraken model that just came out that has like six different models each on completely different tasks to <br>[49:35] Hamel Husain: help route through things oh god please tell me about you could make a really janky version of it like yeah just have a classifier or something the route i think that’s a separate model half of what that was Isn’t the MOE thing, isn’t it trained to route? In the network itself, it’s routing. <br>[49:57] Charles Frye: to a different path more directly than like you know going outside yes okay uh yeah the person the person asking about mixture of laura i think is posting about it in the discord saying like yeah train train laura separately get a router as a yeah laura mixture of experts cracking laura and <br>[50:26] Zack Mueller: The picture is quite literally Cthulhu with a bunch of different fingers pointing to different loras that perform different tasks. <br>[50:33] Charles Frye: Nice. <br>[50:35] Zack Mueller: It’s a collection of experts is what they’re calling it. <br>[50:39] Charles Frye: Oh, boy. <br>[50:41] Zack Mueller: Yeah. Combines the best Python, SQL, function calling, reasoning, and German models by applying dynamic loras so far. <br>[50:53] Charles Frye: Oh, I see. The top tentacle is holding some muesli, I guess. That’s the German one. <br>[50:59] Zack Mueller: Ah, that makes sense. Yeah, dynamic model routing uses a sequence classification model to route inputs to the most suitable language model based on the characteristics. Fascinating. I did drop that in the Discord in case people are getting FOMO. How do you decide a fine tuning project? Even this Lama 3 billion experiment you’re running now, what led you to say, let’s do it? I read the paper, it seemed neat. It seemed like something that was reasonable for me to go and do. The steps were all right there. <br>[51:52] Zack Mueller: It was something where I was like, okay, that’s fine. It’s a pet problem. It doesn’t have to be unique. You could be just recreating what other people did. I think that’s what one of my winning solutions at a little hackathon back in college was. I was quite literally taking the ULM fit lesson from Jeremy’s Fast AI course back in the day and applying it on news articles. And then we just served it. And that all in all took like a day and a half. <br>[52:20] Zack Mueller: And so generally when I think of ideas, it’s sort of what interests me and what’s relevant to what I’m doing right now and try and find a connection there. Either previous work that people have done, especially if it’s open source or data and just go with it. One thing I sort of like about, there’s a quote from one of the guys on Mythbusters, and it basically goes, the difference between just messing around in science is writing it down. Even if you’re just messing around with data, write it down. Great. Now it’s a blog. <br>[52:55] Zack Mueller: You know, model fails? Great. That’s fine. Write it down. That’s a lesson learned. And all it does is bolster you and your experience. There’s another question similarly that you guys might actually have some thoughts on. When you work on a fine tuning project, do you typically get constraints for inference time and memory consumption when you start? Or how do you choose the sweet spot of model size and performance? My first guess would be go off of your budget. That dictates how much VRAM you have available. <br>[53:41] Zack Mueller: And then that dictates what kind of model you can train. Right? On 24090s, I can’t train the 70 billion Lama, but I can train 8 billion and smaller. And time, again, is cost. It’s free for me to just run that for two days, or I can pay $80 and spend up an H100 and get it done in an hour or two. But that’s my thought. What are you guys’thoughts on that? <br>[54:09] Hamel Husain: Yeah, it’s similar. Okay, like the honeycomb example, which I’m going through in this course. <br>[54:14] Hamel Husain: In that situation, the incumbent model was open ai right so you like look at their their latency their cost whatever and that’s like their latency and their cost is pretty good like it’s hard to compete with that now if you’re going to replace there’s a humans have a cognitive bias by the way like once you already have something you value it more same thing with models a lot of times like you’re like it has to be like better it has to be like markedly better for anyone to notice to really notice i mean you can <br>[54:48] Hamel Husain: measure it and stuff but like to really in this case like i also do consulting so i like really need it to be better so like you can noticeably feel it from a user experience perspective. So I want it to be a lot faster. And so in that case, it was pretty clear to me it needs to be a 7 billion parameter model. It needs to be small. It needs to be fast. And I need to actually make the prediction quality higher than GPT 3.5 through fine tuning. So it was kind of like that. <br>[55:20] Hamel Husain: But usually, it’s like, OK, what is the smallest model I can get away with for the quality threshold? Basically. <br>[55:30] Dan Becker: I have a bunch of thoughts on this. I mean, first of all, I generally think of training compute as free. Like we talked about. <br>[55:41] Hamel Husain: It is after this course, yeah. <br>[55:42] Dan Becker: Yeah. With all the credits that you have, you will need to find ways to use compute. So in the past, you would have used 8 billion for a model. And I’m like, well, I got to find something to do with all these credits. But inference is so vastly more expensive for all the projects I work on than training. I just think it’s not even worth thinking about training costs. There’s one project we’re in the middle of working on. I’ve talked about this before. This multimodal alt text generation, so image to text. <br>[56:19] Dan Becker: We’re doing the most expensive training runs that I’ve worked on. And they still like, it’s a trivial fraction of inference costs. It’s not even like a meaningful fraction of the amount of time that we spend talking. Like we, I get paid hourly for that project. The amount of time that I spent on a single call deciding what model to run would cover all the models that we train for weeks. So training really doesn’t matter. And inference is what matters. And then the other thing is the time, like your iteration speed matters. <br>[56:55] Dan Becker: We’ve talked in this course about how important data is. And because data is so important, I typically will start with an 8 billion per meter model because you can iterate faster, see what’s breaking faster. If you want to change later on to a larger model, you can. And what we do is we always start with the 7 or 8 billion per meter model because it’s like a smartish size. You can train it quickly and easily on a single GPU, and it’s nice to not be using distributed GPUs. <br>[57:29] Dan Becker: And then frequently we’ll say, OK, let’s try a bigger model. And then that would have some cost for inference if we end up using a bigger model. And we do that, and then we say, oh, actually, it’s not meaningfully better. <br>[57:45] Dan Becker: And so we almost always end up just deploying 7 or 8 billion perimeter models because they’re a little faster than a 13 billion parameter model or a little cheaper um like you’d use a less powerful gpu um and my experience is that we can’t actually tell the difference when you just side by side look at the results so uh model size is like a less interesting problem than you would expect we just always run seven or eight billion parameter models um and it’s not because we’re scared to train like i would could train a 70 <br>[58:20] Dan Becker: billion parameter and not worry about the cost. It just isn’t worth it. <br>[58:29] Zack Mueller: Let’s see. Here’s an interesting one. Why aren’t people fine tuning more on five three? Is it because it’s smaller? Or is it just mistral small enough with Laura training? I think five series. I don’t know. There’s something weird with the data and how they trained it. That isn’t showing real world performance from what I’ve gathered on Twitter. And that’s generally why people don’t like it. Like, to be biased, I generally make my decisions on what models I look at based on and sort of his experiments. <br>[59:05] Zack Mueller: Because he just sits there and hacks with prompts all day and figures out what he wants to run locally. And for like, I think 12 hours, he said 5.3 was actually good. And then he threw it into his real world scenarios and it didn’t work. Whereas Lama… <br>[59:20] Zack Mueller: 70 billion performed out of the box phenomenal 8 billion is still good for him if he wants to do a small fine tune so it’s just the phi series is weird i think would be an apt way of saying that i guess it’d be cool if it worked but it’s kind of the situation i think where seven or eight billion is kind of the threshold of where things need to be at for things to happen still parameter wise <br>[59:49] Hamel Husain: so you might be on time right yes yeah yeah um <br>[59:55] Dan Becker: I found how to export unanswered questions. So I will export the CSV, drop it into the chat for this session. <br>[1:00:07] Hamel Husain: That’s a great homework for someone to build some kind of RAG application or whatever you want to do. <br>[1:00:14] Dan Becker: Nice. Yeah. So if we want to come back, we have questions both answered and unanswered. save that I’ll share with everyone. And we’ll share this recording, of course.</p>
</div>
</div>
</div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = true;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/parlance-labs\.com\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/HamelHusain">
      <i class="bi bi-twitter" role="img">
</i> 
    </a>
  </li>  
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/hamelsmu">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
</ul>
    <div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/parlance-labs/website/edit/main/education/fine_tuning/zach.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li></ul></div></div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




<script src="../../site_libs/quarto-html/zenscroll-min.js"></script>
</body></html>